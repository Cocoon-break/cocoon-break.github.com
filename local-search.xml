<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL系列四之执行流程及架构</title>
    <link href="/2018/08/22/MySQL%E7%B3%BB%E5%88%97%E5%9B%9B/"/>
    <url>/2018/08/22/MySQL%E7%B3%BB%E5%88%97%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。</p><h3 id="执行流程">  <a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？</p><ol>  <li>    <p>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</p>  </li>  <li>    <p>MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p>  </li>  <li>    <p>MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）</p>  </li>  <li>    <p>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</p>  </li>  <li>    <p>将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。</p>  </li></ol><p>知道执行流程之后，我们看下MySQL的架构图。</p><p>  <img src="/images/mysql/MySQL_Architecture.jpg" srcset="/img/loading.gif" alt></p><p>mysql 逻辑架构主要分为三层</p><ol>  <li>应用层    <ul>      <li>这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client        Connections 和Connect Pool。</li>    </ul>  </li>  <li>核心服务层    <ul>      <li>该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现        : 存储过程、触发器、视图等</li>    </ul>  </li>  <li>存储引擎层    <ul>      <li>可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。</li>    </ul>  </li></ol><p>###架构服务</p><h4 id="应用层的服务">  <a href="#应用层的服务" class="headerlink" title="应用层的服务"></a>应用层的服务</h4><h5 id="链接处理">  <a href="#链接处理" class="headerlink" title="链接处理"></a>链接处理</h5><p>MySQL首先是一个网络程序，其在TCP之上定义了自己的  <a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">应用层协议</a>。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。</p><p>#####身份验证</p><p>每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。</p><h5 id="安全">  <a href="#安全" class="headerlink" title="安全"></a>安全</h5><p>客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。</p><h4 id="核心服务层的服务">  <a href="#核心服务层的服务" class="headerlink" title="核心服务层的服务"></a>核心服务层的服务</h4><h5 id="MySQL服务和实用程序">  <a href="#MySQL服务和实用程序" class="headerlink" title="MySQL服务和实用程序"></a>MySQL服务和实用程序</h5><p>MySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。</p><ul>  <li>备份和恢复</li>  <li>安全</li>  <li>复制</li>  <li>簇</li>  <li>分区</li>  <li>工作台</li></ul><h5 id="SQL接口">  <a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h5><p>SQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</p><h5 id="解析器">  <a href="#解析器" class="headerlink" title="解析器"></a>解析器</h5><p>MySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：</p><ul>  <li>在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。</li>  <li>语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 </li></ul><h5 id="优化器">  <a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，  <strong>与具体的存储引擎实现无关</strong>。</p><h5 id="缓存">  <a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>MySQL缓存（查询缓存）存储  <strong>SELECT</strong> 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。</p><h4 id="存储引擎层的服务">  <a href="#存储引擎层的服务" class="headerlink" title="存储引擎层的服务"></a>存储引擎层的服务</h4><p>存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。</p><pre><code class="mysql">-- 查看MySQL支持的存储引擎SHOW ENGINES;</code></pre><p>  <strong>MySQL5.5以后默认使用InnoDB存储引擎</strong>，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。</p><h5 id="InnoDB">  <a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><p>InnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p><ol>  <li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>  <li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>  <li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>  <li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>  <li>支持自动增加列AUTO_INCREMENT属性。</li></ol><h5 id="MyISAM">  <a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><p>在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。</p><p>MyISAM存储引擎特别适合在以下几种情况下使用：</p><ol>  <li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>  <li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li></ol><p>  <a href="https://zhuanlan.zhihu.com/p/53619907" target="_blank" rel="noopener">更多引擎介绍</a></p><p>本文参考：  <a href="https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html" target="_blank" rel="noopener">https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html</a></p><p>​  <a href="https://zhuanlan.zhihu.com/p/53619907" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53619907</a></p><p>​  <a href="https://www.cnblogs.com/qq1148932219/p/11694064.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL系列三之事务和锁</title>
    <link href="/2018/08/18/MySQL%E7%B3%BB%E5%88%97%E4%B8%89/"/>
    <url>/2018/08/18/MySQL%E7%B3%BB%E5%88%97%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本篇来讲讲MySQL的事务以及锁</p><h3 id="事务">  <a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。</p><p>至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。</p><pre><code class="mysql">show engins;</code></pre><h4 id="事务的特性">  <a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p>事务具有以下的特性</p><ul>  <li>    <p>原子性</p>    <p>事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。</p>  </li>  <li>    <p>一致性</p>    <p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>  </li>  <li>    <p>隔离性</p>    <p>一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。</p>  </li>  <li>    <p>持久性</p>    <p>一旦事务提交，其所做的修改便会永久保存在数据库中。</p>  </li></ul><p>Mysql的提交默认是自动提交，即发送一条sql执行一条。</p><h4 id="事务的提交">  <a href="#事务的提交" class="headerlink" title="事务的提交"></a>事务的提交</h4><p>执行  <code>START TRANSACTION</code> 或  <code>BEGIN</code> 语句后，表示要开启一项事务处理。</p><ul>  <li>COMMIT 提交事务</li>  <li>ROLLBACK 回滚事务</li></ul><pre><code class="mysql">START TRANSACTION;-- 或者beginINSERT INTO stu (class_id,sname,sex)VALUES(2,&#39;张帝&#39;,&#39;女&#39;);COMMIT; -- rollback 回滚事务</code></pre><h4 id="事务隔离">  <a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h4><p>在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？</p><p>当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：</p><ol>  <li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>  <li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>  <li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ol><blockquote>  <p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p></blockquote><p>MySQL拥有不同的事务隔离级别</p><table>  <thead>    <tr>      <th>事务隔离级别</th>      <th>脏读</th>      <th>不可重复读</th>      <th>幻读</th>      <th>说明</th>    </tr>  </thead>  <tbody>    <tr>      <td>读未提交（read-uncommitted）</td>      <td>是</td>      <td>是</td>      <td>是</td>      <td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td>    </tr>    <tr>      <td>不可重复读（read-committed）</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td>    </tr>    <tr>      <td>可重复读（repeatable-read）</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td>    </tr>    <tr>      <td>串行化（serializable）</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td>    </tr>  </tbody></table><h4 id="查询-设置MySQL的事务隔离级别">  <a href="#查询-设置MySQL的事务隔离级别" class="headerlink" title="查询/设置MySQL的事务隔离级别"></a>查询/设置MySQL的事务隔离级别</h4><p>InoDB默认的事务隔离级别是repeatable-read</p><pre><code class="mysql">-- 查询本次会话的事务隔离级别SELECT @@SESSION.transaction_isolation-- 查询全局的事务隔离级别SELECT @@GLOBAL.transaction_isolation-- 设置本次会话的事务隔离级别SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;-- 设置全局的事务隔离级别SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre><h3 id="锁机制">  <a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种</p><ul>  <li>    <p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p>  </li>  <li>    <p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>  </li>  <li>    <p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>  </li></ul><p>  <code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能。</p><ul>  <li>行锁开销大，锁表慢</li>  <li>行锁高并发下可并行处理，性能更高</li>  <li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li>  <li>在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放</li></ul><h4 id="行锁">  <a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><ul>  <li>    <p>使用      <strong>索引字段</strong>为筛选条件，来复现行锁。</p>    <p>事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。</p>    <pre><code class="mysql">-- 事务ABEGIN;UPDATE stu SET sname = &#39;hdcms&#39; WHERE id=1;</code></pre>    <p>事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。</p>    <pre><code class="mysql">-- 事务B 阻塞BEGIN;UPDATE stu SET sname = &#39;hdcms2&#39; WHERE id=1;commit-- 事务B id=2 操作成功BEGIN;UPDATE stu SET sname = &#39;hdcms2&#39; WHERE id=2;commit</code></pre>    <p>当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行</p>    <pre><code class="mysql">-- 事务Acommit</code></pre>  </li>  <li>    <p>使用      <strong>非索引字段</strong>为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。</p>    <p>事务A执行以下代码，因为      <code>sname</code>字段没有添加索引，造成锁定整个表</p>    <pre><code class="mysql">-- 事务A 没有commit，同时sname 字段没有添加索引BEGIN;UPDATE stu SET sname = &#39;hdcms&#39; WHERE sname =&#39;haha1&#39;;</code></pre>    <p>现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态</p>    <pre><code class="mysql">-- 事务B 阻塞，因为stu 表锁BEGIN;update stu set sname = &#39;小明&#39; where id=1commit</code></pre>  </li>  <li>    <p>简单查看MySQL行锁的争用情况</p>    <p>过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>    <pre><code class="mysql">show status like &#39;innodb_row_lock%&#39;;</code></pre>    <p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB      Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>  </li></ul><h4 id="区间锁（页面锁）">  <a href="#区间锁（页面锁）" class="headerlink" title="区间锁（页面锁）"></a>区间锁（页面锁）</h4><ul>  <li>    <p>使用索引字段作为筛选条件</p>    <p>事务A筛选时使用了范围区间</p>    <pre><code class="mysql">-- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住BEGIN;UPDATE goods SET num=200 WHERE id&gt;1 AND id&lt;4;</code></pre>    <p>事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录</p>    <pre><code class="mysql">-- 事务B id=2 无法操作，区间锁BEGIN;update goods set num =1 where id=2;commit;-- 事务B id =4 正常操作BEGIN;update goods set num =1 where id=4;commit;</code></pre>  </li></ul><h4 id="表锁">  <a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>MySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。</p><h5 id="读锁">  <a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>为表设置读锁后，当前会话和其他会话都不可以修改数据。</p><p>会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表</p><pre><code class="mysql">LOCK TABLE goods READ;-- 加读锁UPDATE goods SET num=300 WHERE id=1;SELECT * FROM stu;</code></pre><p>因为会话A对表  <code>goods</code>设置了读锁，所以会话B也不能修改</p><pre><code class="mysql">update goods set num=200 where id=1;-- 阻塞住</code></pre><p>会话A解锁表后，其他会话又可以继续操作表了</p><pre><code class="mysql">UNLOCK TABLES;</code></pre><h5 id="写锁">  <a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。</p><p>会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表</p><pre><code class="mysql">LOCK TABLE goods WRITE; -- 加写锁INSERT INTO goods (name,num )VALUES(&#39;后盾人教程&#39;,300);</code></pre><p>会话B读取/写入/写入表数据都将阻塞</p><pre><code class="mysql">select * from goods;-- 阻塞</code></pre><p>会话A解锁表数据后，其他会话都可以正常操作了</p><pre><code class="mysql">UNLOCK TABLES;</code></pre><h5 id="悲观锁">  <a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。</p><p>事务A执行悲观锁操作后，其他事务执行将被阻塞</p><pre><code class="mysql">-- 没有commit, for update 表示执行悲观锁BEGIN;SELECT * FROM goods WHERE id=1 FOR UPDATE;UPDATE goods SET num=num-2 WHERE id=1;</code></pre><p>事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务</p><pre><code class="mysql">-- 被阻塞，只要等事务A commit之后才会执行B事务BEGIN;SELECT * FROM goods WHERE id=1 FOR UPDATE;commit；</code></pre><h5 id="乐观锁">  <a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p><p>事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）</p><pre><code class="mysql">BEGIN;SELECT * FROM goods WHERE id = 1;</code></pre><p>事务B同时查询，也获取了版本号为0的记录</p><pre><code class="mysql">BEGIN;SELECT * FROM goods WHERE id = 1;</code></pre><p>事务A更改库存，并增加版本号</p><pre><code class="mysql">UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;</code></pre><p>事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。</p><pre><code class="mysql">UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;</code></pre><p>  <a href="https://blog.csdn.net/Jack__Frost/article/details/73347688" target="_blank" rel="noopener">超详细的锁介绍</a></p><p>在对数据进行insert\update\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。</p><ol>  <li>优化sql语句</li>  <li>降低MySQL数据的事务隔离级别</li></ol><p>参考链接：  <a href="https://www.cnblogs.com/qq1148932219/p/11694064.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL系列二之基础使用</title>
    <link href="/2018/08/15/MySQL%E7%B3%BB%E5%88%97%E4%BA%8C/"/>
    <url>/2018/08/15/MySQL%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。</p><h3 id="摘要和排序">  <a href="#摘要和排序" class="headerlink" title="摘要和排序"></a>摘要和排序</h3><p>  <strong>order by</strong></p><p>mysql 排序的关键字为  <strong>order by</strong>，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by  必须放在where 语句后面。多个条件排序则用逗号隔开。</p><pre><code class="mysql">-- 默认学生表，字段有id,class_id,name,birthday,sex-- 根据姓名进行降序排列select * from stu order by name desc;-- 必须放在where语句后面select * from stu where id &gt;=2 order by name;-- 多条件排序select * from stu order by sex asc,birthday desc;</code></pre><p>上面为通用的排序方式，MySQL同时也支持自定义排序通过  <strong>filed()</strong>函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。</p><pre><code class="mysql">-- 根据姓自定义排序SELECT * FROM stu ORDER BY FIELD(left(sname,1),&#39;何&#39;,&#39;赵&#39;);</code></pre><p>  <strong>count函数</strong></p><p>count(字段) 函数不会统计null值，使用count(*)时会将null统计进去。</p><pre><code class="mysql">-- 统计class_id 字段不为null 的条数SELECT COUNT(class_id) FROM stu;-- 和上面语句等价select count(*) from stu where class_id is not null;</code></pre><p>  <strong>min/max 函数</strong></p><p>计算最小值或最大值</p><pre><code class="mysql">-- 获取最小的学生出生年份SELECT year(max(birthday)) from stu;</code></pre><p>  <strong>SUM/AVG</strong>函数</p><p>统计和，统计平局值</p><pre><code class="mysql">-- 统计学生的平均年龄SELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;</code></pre><p>  <strong>distinct 函数</strong></p><p>distinct用于去除结果集中的重复记录</p><pre><code class="mysql">-- 获取所有班级编号SELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;</code></pre><p>  <strong>group by</strong></p><p>在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同  <strong>sql mode</strong>模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！</p><pre><code class="mysql">-- 查看全局的sql_modeSELECT @@GLOBAL.sql_mode;-- 设置全局的sql_modeSET GLOBAL sql_mode = &#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre><p>不同的sql_mode</p><table>  <thead>    <tr>      <th>sql_mode</th>      <th>说明</th>    </tr>  </thead>  <tbody>    <tr>      <td>ONLY_FULL_GROUP_BY</td>      <td>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</td>    </tr>    <tr>      <td>STRICT_TRANS_TABLES</td>      <td>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</td>    </tr>    <tr>      <td>NO_ZERO_IN_DATE</td>      <td>在严格模式下，不允许日期和月份为零</td>    </tr>    <tr>      <td>NO_ZERO_DATE</td>      <td>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</td>    </tr>    <tr>      <td>ERROR_FOR_DIVISION_BY_ZERO</td>      <td>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</td>    </tr>    <tr>      <td>NO_ENGINE_SUBSTITUTION</td>      <td>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</td>    </tr>    <tr>      <td>NO_AUTO_VALUE_ON_ZERO</td>      <td>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</td>    </tr>  </tbody></table><pre><code class="mysql">-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BYSET sql_mode=(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;));-- 根据班级分组查询最小出生日期姓名SELECT min(birthday),sname FROM stu GROUP BY class_id;</code></pre><p>使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组</p><pre><code class="mysql">SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2;</code></pre><h3 id="多表操作">  <a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><p>在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。</p><p>先看下图，一下所有的inner可以通过该图来理解。</p><p>  <img src="/images/mysql/join.jpg" srcset="/img/loading.gif" alt></p><p>  <strong>INNER</strong></p><p>所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用  <strong>inner join</strong> 后面跟着ON，ON后面跟的是条件</p><pre><code class="mysql">-- 获取用户信息select * from stu as s,user_info as i where s.id = i.stu_id;-- 使用inner 来进行多表查询，和上面的语句是等价的SELECT * FROM stu AS s INNER JOIN user_info as i ON s.id = i.stu_id;</code></pre><p>  <strong>OUTER JOIN</strong></p><p>外链接包括  <code>LEFT JOIN</code> 与  <code>RIGHT JOIN</code> ，可以简单理解为  <code>LEFT JOIN</code>会包含左侧所有表记录，  <code>RIGHT JOIN</code> 会包含右侧表全部记录。</p><p>左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。</p><pre><code class="mysql">-- 获取没有设置QQ的用户SELECT s.sname FROM stu AS s LEFT JOIN user_info as iON s.id = i.stu_idWHERE i.qq is null;</code></pre><p>同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left  join 是相反的。</p><pre><code class="mysql">-- 哪个班级没有学生SELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as cON s.class_id = c.idWHERE s.id IS NULL;</code></pre><p>  <strong>SELF JOIN</strong></p><p>  <code>SELF JOIN</code>为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是  <strong>子查询操作的是两次性能会比自连接消耗性能</strong>。</p><pre><code class="mysql">-- 使用子查询操作SELECT * FROM stu WHERE class_id = (SELECT class_id FROM stu WHERE sname = &#39;后盾人&#39;)AND stu.sname !=&#39;后盾人&#39;;-- 使用自连接操作SELECT s1.sname,s2.sname FROM stu as s1 INNER JOIN stu as s2ON s1.class_id = s2.class_idWHERE s1.sname = &#39;后盾人&#39; AND s2.sname !=&#39;后盾人&#39;;</code></pre><p>  <strong>UNION</strong></p><p>  <code>UNION</code> 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。</p><ul>  <li>UNION会过滤重复的结果</li>  <li>UNION ALL 不过滤重复结果</li>  <li>列表字段由是第一个查询的字段</li></ul><pre><code class="mysql">-- 查询年龄最大与最小的同学(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)UNION(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)ORDER BY birthday DESC;</code></pre><p>本文参考链接  <a href="[http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html">后盾人MySQL教程</a>)</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL系列一之基础使用</title>
    <link href="/2018/08/12/MySQL%E7%B3%BB%E5%88%97%E4%B8%80/"/>
    <url>/2018/08/12/MySQL%E7%B3%BB%E5%88%97%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>MySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker  的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。</p><h3 id="链接MySQL服务">  <a href="#链接MySQL服务" class="headerlink" title="链接MySQL服务"></a>链接MySQL服务</h3><p>通过命令行建立链接</p><pre><code class="shell"># -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作mysql -uroot -proot -P3306 -h 127.0.0.1mysql -uroot -proot -e&quot;show databases&quot; # 建立链接的同时，执行提前写好的sql文件mysql -uroot -proot &lt; test.sql</code></pre><h3 id="数据库管理">  <a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><p>数据库管理包括，数据库创建，数据库删除，数据库使用等操作</p><pre><code class="mysql">-- 创建数据库并指定字符集create database test charset utf8;-- 数据库查看show databases;-- 删除数据库drop database test;-- 一般为了删除不存在的数据库报错，可以通过if exitsdrop database if exits test;-- 使用数据库use test;</code></pre><h3 id="数据表管理">  <a href="#数据表管理" class="headerlink" title="数据表管理"></a>数据表管理</h3><p>数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改</p><pre><code class="mysql">-- 创建class 表id 自增，同时指定表字符集create table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;-- 数据表插入单条数据，和多条数据INSERT INTO class set cname =&#39;golang&#39;,description=&#39;开发语言&#39;;INSERT INTO class (cname,description) VALUES(&#39;PHP&#39;,&#39;开发语言&#39;),(&#39;Mysql&#39;,&#39;数据库&#39;);-- 数据表删除单条记录delete from class where cname=&#39;golang&#39;;-- 数据表修改单条记录update class set cname = &quot;PHP2&quot; where id=2;-- 删除表drop table if exits class;</code></pre><p>创建数据模板表，后续可以根据模板表创建新的数据表</p><pre><code class="mysql">-- 复制表结构create table tcopy like class;-- 复制表同时复制数据create table tcopy select * from class;</code></pre><p>数据表字段名称修改以及字段增删</p><pre><code class="mysql">-- 数据表重命名alter table class rename classes;rename table classes to class;-- 数据表增加字段alter table class add school varchar(50);-- 数据表删除字段alter table class drop school;-- 修改字段名alter table class CHANGE description descriptions varchar(30);</code></pre><p>数据表相关主键操作，主键的增删</p><pre><code class="mysql">-- 主键为自增字段，需要删除自增属性后才可以删除主键alter table class MODIFY id int not null;-- 删除自增alter table class DROP PRIMARY key;-- 删除主键-- 添加表主键alter table class add PRIMARY KEY(id);-- 添加表主键alter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列alter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</code></pre><h3 id="数据类型">  <a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>MySQL数据类型包括字符串，数值类型，枚举类型</p><p>  <strong>字符串数据类型</strong></p><table>  <thead>    <tr>      <th style="text-align:left">类型</th>      <th style="text-align:left">大小</th>      <th style="text-align:left">用途</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align:left">CHAR</td>      <td style="text-align:left">0-255字节</td>      <td style="text-align:left">定长字符串</td>    </tr>    <tr>      <td style="text-align:left">VARCHAR</td>      <td style="text-align:left">0-65535 字节</td>      <td style="text-align:left">变长字符串</td>    </tr>    <tr>      <td style="text-align:left">TINYBLOB</td>      <td style="text-align:left">0-255字节</td>      <td style="text-align:left">不超过 255 个字符的二进制字符串</td>    </tr>    <tr>      <td style="text-align:left">TINYTEXT</td>      <td style="text-align:left">0-255字节</td>      <td style="text-align:left">短文本字符串</td>    </tr>    <tr>      <td style="text-align:left">BLOB</td>      <td style="text-align:left">0-65 535字节</td>      <td style="text-align:left">二进制形式的长文本数据</td>    </tr>    <tr>      <td style="text-align:left">TEXT</td>      <td style="text-align:left">0-65 535字节</td>      <td style="text-align:left">长文本数据</td>    </tr>    <tr>      <td style="text-align:left">MEDIUMBLOB</td>      <td style="text-align:left">0-16 777 215字节</td>      <td style="text-align:left">二进制形式的中等长度文本数据</td>    </tr>    <tr>      <td style="text-align:left">MEDIUMTEXT</td>      <td style="text-align:left">0-16 777 215字节</td>      <td style="text-align:left">中等长度文本数据</td>    </tr>    <tr>      <td style="text-align:left">LONGBLOB</td>      <td style="text-align:left">0-4 294 967 295字节</td>      <td style="text-align:left">二进制形式的极大文本数据</td>    </tr>    <tr>      <td style="text-align:left">LONGTEXT</td>      <td style="text-align:left">0-4 294 967 295字节</td>      <td style="text-align:left">极大文本数据</td>    </tr>  </tbody></table><p>CHAR类型是定长的数据类型，比如定义20长度的  <code>char</code>类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。</p><p>VARCHAR类型是变长数据类型，空间受内容长度影响。</p><p>  <strong>字符串常用函数</strong></p><table>  <thead>    <tr>      <th>函数名</th>      <th>作用</th>      <th>示例</th>    </tr>  </thead>  <tbody>    <tr>      <td>UPPER()/LOWER()</td>      <td>将内容全部改成大写/小写</td>      <td>select UPPER(cname) from class;</td>    </tr>    <tr>      <td>CONCAT()</td>      <td>字符拼接</td>      <td>select concat(cname,description) from class;</td>    </tr>    <tr>      <td>Left()/Right()</td>      <td>用于取左或右指定数量的字符</td>      <td>select left(cname,3) from class;</td>    </tr>    <tr>      <td>mid</td>      <td>从中间取字符串</td>      <td>select * from class where mid(cname,2,2) = ‘hp’;</td>    </tr>    <tr>      <td>substring</td>      <td>从指定位置开始向右截取字符串</td>      <td>select * from class where SUBSTRING(cname,2) = ‘hp’;</td>    </tr>    <tr>      <td>char_length</td>      <td>获取字符串数量</td>      <td>select char_length(cname) from class;</td>    </tr>  </tbody></table><p>正则表达式和like的使用</p><pre><code class="mysql">-- 正则匹配php 或者MySQLSELECT * FROM class WHERE cname REGEXP &#39;php|mysql&#39;;-- _用于匹配一个字符，%用于匹配任意多个字符SELECT *  FROM class WHERE cname LIKE &#39;_h%&#39;;</code></pre><p>  <strong>数值整型类型</strong></p><table>  <thead>    <tr>      <th>MySQL数据类型</th>      <th>含义（有符号）</th>    </tr>  </thead>  <tbody>    <tr>      <td>tinyint(m)</td>      <td>1个字节 范围(-128~127)</td>    </tr>    <tr>      <td>smallint(m)</td>      <td>2个字节 范围(-32768~32767)</td>    </tr>    <tr>      <td>mediumint(m)</td>      <td>3个字节 范围(-8388608~8388607)</td>    </tr>    <tr>      <td>int(m)</td>      <td>4个字节 范围(-2147483648~2147483647)</td>    </tr>    <tr>      <td>bigint(m)</td>      <td>8个字节 范围(+-9.22*10的18次方)</td>    </tr>  </tbody></table><p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。</p><p>  <strong>数值浮点型</strong></p><table>  <thead>    <tr>      <th style="text-align:left">类型</th>      <th style="text-align:left">大小</th>      <th style="text-align:left">范围（有符号）</th>      <th style="text-align:left">范围（无符号）</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align:left">FLOAT</td>      <td style="text-align:left">4 字节</td>      <td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466        351 E+38)</td>      <td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>    </tr>    <tr>      <td style="text-align:left">DOUBLE</td>      <td style="text-align:left">8 字节</td>      <td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073        858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>      <td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>    </tr>    <tr>      <td style="text-align:left">DECIMAL</td>      <td style="text-align:left">DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td>      <td style="text-align:left">依赖于M和D的值</td>      <td style="text-align:left">依赖于M和D的值</td>    </tr>  </tbody></table><p>  <strong>ENUM/SET</strong></p><p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。</p><p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。</p><h3 id="日期时间">  <a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><table>  <thead>    <tr>      <th>日期时间类型</th>      <th>占用空间</th>      <th>日期格式</th>      <th>最小值</th>      <th>最大值</th>      <th>零值表示</th>    </tr>  </thead>  <tbody>    <tr>      <td>DATETIME</td>      <td>8 bytes</td>      <td>YYYY-MM-DD HH:MM:SS</td>      <td>1000-01-01 00:00:00</td>      <td>9999-12-31 23:59:59</td>      <td>0000-00-00 00:00:00</td>    </tr>    <tr>      <td>TIMESTAMP</td>      <td>4 bytes</td>      <td>YYYY-MM-DD HH:MM:SS</td>      <td>1970-01-01 08:00:01</td>      <td>2038-01-19 03:14:07</td>      <td>00000000000000</td>    </tr>    <tr>      <td>DATE</td>      <td>4 bytes</td>      <td>YYYY-MM-DD</td>      <td>1000-01-01</td>      <td>9999-12-31</td>      <td>0000-00-00</td>    </tr>    <tr>      <td>TIME</td>      <td>3 bytes</td>      <td>HH:MM:SS</td>      <td>-838:59:59</td>      <td>838:59:59</td>      <td>00:00:00</td>    </tr>    <tr>      <td>YEAR</td>      <td>1 bytes</td>      <td>YYYY</td>      <td>1901</td>      <td>2155</td>      <td>0000</td>    </tr>  </tbody></table><p>Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,</p><p>创建字段</p><pre><code class="sql">ALTER TABLE class ADD create_at datetime default null;</code></pre><p>对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档</p><table>  <thead>    <tr>      <th>参数</th>      <th>描述</th>    </tr>  </thead>  <tbody>    <tr>      <td>%Y</td>      <td>年，4 位</td>    </tr>    <tr>      <td>%y</td>      <td>年，2位</td>    </tr>    <tr>      <td>%M</td>      <td>月名</td>    </tr>    <tr>      <td>%m</td>      <td>月，数值(00-12)</td>    </tr>    <tr>      <td>%H</td>      <td>小时 (00-23)</td>    </tr>    <tr>      <td>%h</td>      <td>小时 (01-12)</td>    </tr>    <tr>      <td>%i</td>      <td>分钟，数值(00-59)</td>    </tr>    <tr>      <td>%s</td>      <td>秒(00-59)</td>    </tr>    <tr>      <td>%r</td>      <td>时间，12-小时（hh:mm:ss AM 或 PM）</td>    </tr>  </tbody></table><p>使用示例</p><pre><code class="mysql">select cname,DATE_FORMAT(create_at,&#39;%Y年%m月%d %H时%i分%s秒&#39;) as create_at from class;select cname,TIME_FORMAT(create_at,&#39;%r&#39;) as create_at from class;</code></pre><p>  <strong>添加数据时自动更新时间</strong></p><pre><code class="mysql">alter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;</code></pre><p>只要该条记录有任何一个字段被修改，则自动更新update_at字段的值</p><p>  <strong>常用函数</strong></p><table>  <thead>    <tr>      <th>函数</th>      <th>说明</th>    </tr>  </thead>  <tbody>    <tr>      <td>HOUR</td>      <td>小时</td>    </tr>    <tr>      <td>MINUTE</td>      <td>分</td>    </tr>    <tr>      <td>SECOND</td>      <td>秒</td>    </tr>    <tr>      <td>YEAR</td>      <td>年</td>    </tr>    <tr>      <td>MONTH</td>      <td>月</td>    </tr>    <tr>      <td>DAY</td>      <td>日</td>    </tr>    <tr>      <td>TIME</td>      <td>获取时间</td>    </tr>    <tr>      <td>WEEK</td>      <td>周</td>    </tr>    <tr>      <td>QUARTER</td>      <td>季</td>    </tr>    <tr>      <td>CURRENT_DATE（CURDATE）</td>      <td>当前日期</td>    </tr>    <tr>      <td>CURRENT_TIME</td>      <td>当前时间</td>    </tr>    <tr>      <td>NOW</td>      <td>当前时间</td>    </tr>    <tr>      <td>DAYOFYEAR</td>      <td>一年中的日数</td>    </tr>    <tr>      <td>DAYOFMONTH</td>      <td>月份中日数</td>    </tr>    <tr>      <td>DAYOFWEEK</td>      <td>星期天（1）到星期六（7）</td>    </tr>    <tr>      <td>WEEKDAY</td>      <td>星期一（0）到星期天（6）</td>    </tr>    <tr>      <td>TO_DAYS</td>      <td>从元年到现在的天数（忽略时间部分）</td>    </tr>    <tr>      <td>FROM_DAYS</td>      <td>根据天数得到日期（忽略时间部分）</td>    </tr>    <tr>      <td>TIME_TO_SEC</td>      <td>时间转为秒数（忽略日期部分）</td>    </tr>    <tr>      <td>SEC_TO_TIME</td>      <td>根据秒数转为时间（忽略日期部分）</td>    </tr>    <tr>      <td>UNIX_TIMESTAMP</td>      <td>根据日期返回秒数（包括日期与时间）</td>    </tr>    <tr>      <td>FROM_UNIXTIME</td>      <td>根据秒数返回日期与时间（包括日期与时间）</td>    </tr>    <tr>      <td>DATEDIFF</td>      <td>两个日期相差的天数（忽略时间部分）</td>    </tr>    <tr>      <td>TIMEDIFF</td>      <td>计算两个时间的间隔（忽略日期部分）</td>    </tr>    <tr>      <td>TIMESTAMPDIFF</td>      <td>根据指定单位计算两个日期时间的间隔（包括日期与时间）</td>    </tr>    <tr>      <td>LAST_DAY</td>      <td>该月的最后一天</td>    </tr>  </tbody></table><p>使用示例</p><pre><code class="mysql">-- 使用函数分割时间select cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;-- 当前时间SELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();-- 时间计算SELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());</code></pre><p>  <strong>时间计算 常用函数 </strong></p><table>  <thead>    <tr>      <th>函数</th>      <th>说明</th>    </tr>  </thead>  <tbody>    <tr>      <td>ADDTIME</td>      <td>添加时间（负数为减少），只对时间有效</td>    </tr>    <tr>      <td>TIMESTAMP</td>      <td>添加时间（负数为减少），只对时间有效</td>    </tr>    <tr>      <td>DATE_ADD</td>      <td>根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB)</td>    </tr>    <tr>      <td>DATE_SUB</td>      <td>DATE_ADD的反函数</td>    </tr>    <tr>      <td>LAST_DAY</td>      <td>指定月最后一天日期</td>    </tr>  </tbody></table><p>使用示例</p><pre><code class="mysql">-- 获取七小时之前的时间select ADDTIME(now(),&#39;-7:00:00&#39;)-- 获取七天之后的时间，interval表示间隔SELECT DATE_ADD(now(),INTERVAL 7 DAY);-- 获取本月第一天的日期SELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);</code></pre><p>本文参考链接  <a href="[http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html">后盾人MySQL教程</a>)</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>身份证识别跑批脚本</title>
    <link href="/2018/03/21/%E8%84%9A%E6%9C%AC%E8%B7%91%E6%89%B9/"/>
    <url>/2018/03/21/%E8%84%9A%E6%9C%AC%E8%B7%91%E6%89%B9/</url>
    
    <content type="html"><![CDATA[<p>使用shell对文件夹进行遍历处理，最后通过markdown生成可视化的结果文件。比较适合对少量数据进行结果快速比对</p><ul>  <li>    <p>shell脚本遍历子目录及子目录下的文件，并将文件去发请求，把接口返回回来的json写入到文件中</p>    <pre><code class="shell">#!/bin/bashfunction getdir(){    url = $2    for element in `ls $1`    do          dir_or_file=$1&quot;/&quot;$element        if [ -d $dir_or_file ]        then             getdir $dir_or_file        else            filepath=${dir_or_file%.*}            #不带文件后缀的文件路径            filename=${filepath//\//\_}            #把文件路径中的反斜线换成下划线            if [ -e ${dir_or_file%.*}.jpg ]            then                 curl -F img=@${dir_or_file%.*}.jpg $url &gt; idcard_result/${filename}.json                elif [ -e ${dir_or_file%.*}.png ]               then                curl -F img=@${dir_or_file%.*}.png $url &gt; idcard_result/${filename}.json            fi        fi      done}parentpath=$1mkdir idcard_resulturl=http://10.201.102.163:9002/faceid/v1/idcard#echo $parentpath http://10.201.102.163:9002/faceid/v1/idcardecho $urlgetdir $parentpath $url</code></pre>  </li>  <li>    <p>python 比较身份证正确答案的json文件和ocr识别结果的文件进行核对，统计是否识别正确。python版本为2.7.13。以下为check.py的源码,因为在python2.7里json.load出来的json      是unicode编码的，所以比较的时候在自己的中文中添加U。如：std[U’姓名’]</p>    <a id="more"></a>    <pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import sysimport jsonreload(sys)sys.setdefaultencoding(&#39;utf-8&#39;)def startcheck(originfile, ocrfile):    with open(originfile, &#39;r&#39;) as f:        std = json.load(f, encoding=&#39;utf-8&#39;)    with open(ocrfile, &#39;r&#39;) as f:        rst = json.load(f, encoding=&#39;utf-8&#39;)    result = True    if rst[&#39;side&#39;] == &#39;front&#39;:        bd = rst[&#39;birthday&#39;]        bd_date = bd[&#39;year&#39;] + &#39;年&#39; + bd[&#39;month&#39;] + &#39;月&#39; + bd[&#39;day&#39;] + &#39;日&#39;        if rst[&#39;name&#39;] != std[U&#39;姓名&#39;]:            result = False        if rst[&#39;gender&#39;] != std[U&#39;性别&#39;]:            result = False        if rst[&#39;race&#39;] != std[U&#39;民族&#39;]:            result = False        if bd_date != std[U&#39;出生&#39;]:            result = False        if rst[&#39;address&#39;] != std[U&#39;住址&#39;]:            result = False        if rst[&#39;id_card_number&#39;] != std[U&#39;公民身份号码&#39;]:            result = False    else:        if rst[&#39;issued_by&#39;] != std[U&#39;签发机关&#39;]:            result = False        if rst[&#39;valid_date&#39;] != std[U&#39;有效期&#39;]:            result = False    strResult = str(result)    content = &#39;%s,%s,%s,\n&#39; % (originfile, ocrfile, strResult)    with open(&#39;./check_result.csv&#39;, &#39;a&#39;) as f:        f.write(content)if __name__ == &#39;__main__&#39;:    originfile_path = sys.argv[1]    print &#39;originfile_path:::&#39;, originfile_path    ocrfile_path = sys.argv[2]    print &#39;ocrfile_path:::&#39;, ocrfile_path    startcheck(originfile_path, ocrfile_path)</code></pre>    <pre><code class="shell">python check.py real.json ocr.json</code></pre>    <p>real.json</p>    <pre><code class="json">{  &quot;住址&quot;: &quot;山东省招远市温泉路309号&quot;,  &quot;姓名&quot;: &quot;杜英男&quot;,  &quot;民族&quot;: &quot;汉&quot;,  &quot;性别&quot;: &quot;女&quot;,  &quot;公民身份号码&quot;: &quot;230122195807160467&quot;,  &quot;出生&quot;: &quot;1988年7月16日&quot;}</code></pre>    <p>ocr.json</p>    <pre><code class="json">{  &quot;address&quot;: &quot;湖南省长沙县安沙镇泗洲村龙口组337号&quot;,  &quot;address_confidence&quot;: [],  &quot;birthday&quot;: {    &quot;day&quot;: &quot;11&quot;,    &quot;day_confidence&quot;: [],    &quot;month&quot;: &quot;2&quot;,    &quot;month_confidence&quot;: [],    &quot;year&quot;: &quot;1994&quot;,    &quot;year_confidence&quot;: []  },  &quot;card_bound&quot;: {},  &quot;gender&quot;: &quot;男&quot;,  &quot;gender_confidence&quot;: [],  &quot;head_rect&quot;: {},  &quot;id_card_number&quot;: &quot;430121198402117321&quot;,  &quot;idnumber_confidence&quot;: [],  &quot;name&quot;: &quot;王威一&quot;,  &quot;name_confidence&quot;: [],  &quot;race&quot;: &quot;汉&quot;,  &quot;race_confidence&quot;: [],  &quot;request_id&quot;: &quot;1521613434,cdc90cd4-ea2e-4bf9-b112-bce711ba2e90&quot;,  &quot;side&quot;: &quot;front&quot;,  &quot;time_used&quot;: 346}</code></pre>  </li></ul><ul>  <li>    <p>切分文件进行比对，同时生成md文件，通过typora导出pdf可视化文件</p>    <pre><code class="shell">#!/bin/bashfor f in `ls -v *.jpg | grep _ |cut -d_ -f 1 |uniq -c |awk &#39;{print $2}&#39;`do#echo ${f}_0.jpga=`curl -F image_idcard=@${f}_0.jpg -F image_best=@${f}_1.jpg -F watermark=1 http://10.201.102.104:9000/verify | jq -c -r .confidence`echo ![img](http://localhost:8080/${f}_0.jpg) ![img](http://localhost:8080/${f}_1.jpg) &gt;&gt;$a.md #echo ${f}_0.jpg ${f}_1.jpg $a &gt;&gt; a.logdone</code></pre>    <p>ls -v 排序列出所有文件</p>    <p>grep _ 标记出带有下滑线的</p>    <p>cut -d _ -f 1 将文件按下划线切分取第一部分</p>    <p>uniq -c 显示重复的数量和cut -d _ -f 1的部分</p>    <p>awk ‘{print $2}’ 打印出cut -d _ -f 1部分</p>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密算法简介</title>
    <link href="/2017/08/28/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2017/08/28/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>​ 对于加密算法我也不是很熟，只能是单纯去使用，但是最近做项目时涉及到国密算法，由于个人对算法差不多是七窍通了六窍，一窍不通啊。于是同事给我科普了一下。</p><p>​ 先将加密算法分两个大方向：1. 不可逆的加密算法 2. 不可逆的加密算法</p><h2 id="不可逆的加密算法">  <a href="#不可逆的加密算法" class="headerlink" title="不可逆的加密算法"></a>不可逆的加密算法</h2><p>​ 不可以逆的意思就是说，加密之后，你也不知道加密前的明文。如果要确认加密前的明文，你只能重新将明文加密一遍，看两次得出来的密文是否一致。不可逆加密算法的特征是加密过程中不需要使用密钥，直接输入明文通过算法处理后得到密文。</p><p>​ 典型的不可逆的加密算法是  <strong>MD5</strong> : MD5对要加密的对象没有大小限制，加密之后的密文长度为  <strong>128bit</strong>,这里是128bit和字节是不一样的，转换成字节的话也就是16Byte。</p><pre><code class="sh">~/tmp » md5 test.jpgMD5 (test.jpg) = f368d709b8652bf78f9ce61d9fd70d7a</code></pre><p>上面的例子通过md5加密了一张图片, MD5加密之后得到值是128bit，按4位二进制组合成一个十六进制，所以得出来的十六进制字符串是32个。</p><p>一般来说不可逆的加密算法得出来的密文是定长的，无论要加密的内容大小是多少，如md5是32，sha256是64，sha512是128</p><a id="more"></a><h2 id="可逆的加密算法">  <a href="#可逆的加密算法" class="headerlink" title="可逆的加密算法"></a>可逆的加密算法</h2><p>​ 可逆的加密算法就是加密之后，还是有办法能够得到明文。可逆的加密算法又可分为对称加密和非对称加密。RSA就是典型的非对称的可逆加密算法。</p><ol>  <li>    <p>对称的可逆加密算法</p>    <p>对称的加密算法，加密和解密用的都是同一个密钥，这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。对称加密算法的特点是算法公开、计算量小、加解密速度快、加解密效率高</p>  </li>  <li>    <p>非对称的可逆加密算法</p>    <p>非对称密钥算法是指一个加密算法的加密密钥和解密密钥是不一样的，或者说不能由其中一个密钥推导出另一个密钥。这两个密钥其中一个称为公钥，用于加密，是公开的，另一个称为私钥，用于解密，是保密的。其中由公钥计算私钥是计算上不可行的。</p>  </li></ol><ul>  <li>分组加密    <ul>      <li>向量加密</li>    </ul>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网端口映射到外网</title>
    <link href="/2017/08/21/%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91/"/>
    <url>/2017/08/21/%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>​ 最近有一个客户想要看我们的产品，想体验一下我们的产品，需要我们提供一个小程序，于是就弄了一个小程序给客户，小程序还好说我们有现成的东西，直接给客户，麻烦的是小程序背后的服务。由于我们背后的人脸识别服务都是私有化部署的，而且这个客户只是想临时体验一下，所以将整个服务部署到公有云完全是没有必要的。但是我们内部有已经部署好的，又不想在公有云上去搭建一套。于是去咨询了下同事，是不是有什么工具可以把内网的端口暴露到公网上。然后同事就介绍了一个工具  <code>autossh</code></p><p>​ 好了背景介绍完了，接下来就是去实践了。</p><p>现有两台服务器：服务器A是阿里云上的一台机器，服务器B是公司内部的一台虚拟机，这个台虚拟机必须是可以连接公网的。</p><a id="more"></a><ol>  <li>    <p>登录到服务B上</p>    <pre><code class="sh">#1.将autossh下载到服务器B上wget http://fossies.org/Linux/privat/autossh-1.4e.tgz#2.解压tar xzvf autossh-1.4e.tgz#3. 编译安装 cd autossh-1.4e ./configure make make install#4. 生成服务器B的公钥，一会儿需要把服务器B的公钥添加到服务器A上ssh-keygen#5. 执行ssh-keygen 一路回车即可，这个会在~/.ssh目录下生成id_rsa.pub,编辑这个文件，把内容复制到一个文本文件vim ~/.ssh/id_rsa.pub</code></pre>  </li></ol><ol>  <li>    <p>登录到服务器A上</p>    <pre><code class="sh">#1.在~/.ssh目录下创建authorized_keys文件touch ~/.ssh/authorized_keys#2.编辑这个文件并将刚才从服务器A上复制的公钥粘贴到这个文件上，保存退出即可vim ~/.ssh/authorized_keys</code></pre>  </li>  <li>    <p>登录到服务器B上</p>    <pre><code class="sh">#1.制定需要暴露到公网端口autossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa 服务器A的用户名@服务器A的IP地址</code></pre>    <p>参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连</p>    <p>后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口</p>  </li></ol><p>到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>私有化的坑</title>
    <link href="/2017/07/20/%E7%A7%81%E6%9C%89%E5%8C%96%E7%9A%84%E5%9D%91/"/>
    <url>/2017/07/20/%E7%A7%81%E6%9C%89%E5%8C%96%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>​ 最近遇到的坑确实是有点多了，这里记录一下。事情开始是这样的，想将公有云的一套工程进行私有化，因为公有云的是自己的系统，不用考虑太多的因素，想统一环境还是比较容易的，只要能够在一套环境成功运行，其他的直接copy就行。但是私有云就不行了，各个客户使用的环境都有一定的差异。私有化就是将使这个工程能够在不同的环境运行。</p><p>​ 公有云的这套工程是python工程，python工程使用了一些so库。而这些so库又依赖系统的  <code>/lib64/libc.so.6</code>，然后工程就报  <code>version &quot;GLIBC_2.14&quot; not found</code>,原因是系统libc不支持GLIBC_2.14这个版本，这时我就有两个解决方案，一个是我将系统的libc.so.6  升级，还有一个我弄一个统一的环境。很显然方案一不是私有云，我总不能让我所有的客户去升级libc.so.6吧，着很显然不符合私有化。</p><p>​ 在尝试方案一的过程中，我发现原来把一个Linux系统弄崩其实很简单，崩了之后各种无法使用，你只能去重装系统。你只要执行  <code>mv /lib64/libc.so.6 /lib64/libc.so.6.bak</code>,你会发现接下来无论你输入什么命令都不好使了。这是因为  <code>/lib64/libc.so.6</code>是最底层的库，系统上的程序基本是依赖这个库的。所以/lib64下的so库不要轻易去动。</p><a id="more"></a><p>​ 于是我去尝试了第二种方案，弄一个统一的环境，那要怎么弄呢？so 库是依赖系统的libc.so.6，我要怎么让我的这个工程的so不去依赖/lib64 下的so而是去依赖我指定的一个路径的so呢？</p><ol>  <li>    <p>我先用docker搭建一个可以运行工程的环境，使用docker弄了一个ubuntu的系统。以下是一些使用的命令</p>    <pre><code class="sh">docker pull ubuntu #获取ubuntu的镜像docker run -it --name kas -v /Users/wushengping/dockerUbuntu:/go -p 9001:9001 ubuntu bash #第一次以交互模式启动ubuntu，并命名为kas，同时将ubuntu系统端口9001映射到本机上docker ps -a #查看docker 下所有container状态docker start kas # 启动kas,kas是ubuntu系统镜像，只是启动并为进入交互模式docker exec -it kas bash #进入ubuntu 交互模式</code></pre>  </li>  <li>    <p>在ubuntu上可以正常运行之后，通过ldd 的命令将so依赖的系统相关的so 导出来,同时将/lib64/ld-linux-x86-64.so.2 也导出来</p>    <pre><code class="sh">  cp `ldd xxxx.so | awk &#39;{print $3}&#39; | grep &#39;^[^(]&#39;` ~/libs  cp /lib64/ld-linux-x86-64.so.2  ~</code></pre>  </li>  <li>    <p>将刚才的导出的库，传到redhats6.4系统上，然后指定工程运行所需的依赖库。</p>    <pre><code class="sh">  ld-linux-x86-64.so.2 --library-path ./libs python xxxx #xxx表示工程的入口文件</code></pre>    <p> 这时你会发现这个工程起都起不来了，并报了core dump 的错误，这时因为指定路径之后，只能通过二进制的方式去启动这个工程。而python 只是一个命令，并不是二进制的文件，无法执行。这里需要注意的是ld-linux-x86-64.so.2      只能是刚才从ubuntu导出来的文件，否则也会报core dump</p>  </li>  <li>    <p>在第三步我们没有成功运行起来，是因为我们还缺少将python工程编译成一个二进制可执行的文件。      <strong>pyInstaller</strong> 这个工具可以将python工程打成一个二进制的包，同时会将工程依赖的库也打进这个二进制。</p>    <pre><code class="sh">  pyinstall -f entry.py #entry.py 是你整个工程的入口文件</code></pre>    <p> 执行完成之后会生成一个dist目录，目录下有整个工程的二进制文件</p>  </li>  <li>    <p>整个私有化的流程算是完成了交付给客户的时候包括一下文件</p>    <ul>      <li>ld-linux-x86-64.so.2</li>      <li>libs </li>      <li>        <p>可执行的二进制文件</p>        <p>当然实际交付的工程中有更多的文件，看工程是怎么规划的。这里不过多解释</p>      </li>    </ul>  </li></ol><p>本篇文章主要是记录私有化工程的一些思路，过程中遇到的很多坑。很多细节这里也不去体现了。大家自行领会。其中关于的docker的使用和pyinstaller 的安装使用，不是本篇文章的重点。可以自行谷歌</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xargs 和 jq</title>
    <link href="/2017/07/05/xargs%E5%92%8Cjq/"/>
    <url>/2017/07/05/xargs%E5%92%8Cjq/</url>
    
    <content type="html"><![CDATA[<p>​ xargs是Linux系统上自带的命令，xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。jq 不是Linux系统自带的命令，需要自行安装。jq主要在Linux上解析json。</p><h2 id="xargs">  <a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>​ 举一个例子，我们常用的一个命令  <code>rm -rf *.log</code> 如果文件log文件太多我们会得到一个异常的信/bin/rm Argument list too long，也就是说rm能接受的参数是有限的。这时我们就可以利用xargs  过滤。</p><pre><code class="sh">ls *.log | xargs rm -rf</code></pre><p>ls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。</p><p>  <strong>题外话：</strong> Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：  <code>rm -rf -xxxx.log</code>是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。可以通过在文件名前加两个减号解决。</p><p>如  <code>rm -rf -- -xxxx.log</code></p><p>​ xargs 的具体用法，还是一个文件夹中有一大堆文件，通过  <code>ls</code>可以将文件多行输出。但是我想单行或者指定行数输出呢！通过给xargs指定-n 参数。</p><pre><code class="sh">ls *.log | xargs -n2 #-n2 就是指定两行输出，-n3就是三行输出，以此类推</code></pre><p>前面都是一些简易的操作，感觉不到xargs 到底是怎么处理管道出来的文件。现在我的一个需求是将所有的log文件复制到指定目录下。普通复制命令  <code>cp xxx.log /var/log</code>。我们先忽略cp 命令有-r参数。先看看以下写法是否正确</p><a id="more"></a><pre><code class="sh">ls *.log | xargs cp /var/log</code></pre><p>你一看立马就觉得不对，cp 不是接受两个参数吗？一个文件，一个目标文件或路径。可是又不知道怎么去解决这个事。在我们上面的例子都真正没有去理解xargs，如  <code>ls *.log | xargs rm -rf</code> 为什么能好使？ls出来的文件通过管道传递给xargs 过滤，然后xargs 过滤出的文件默认追加到命令行的最后。但是在这个例子中，我们不想将xargs吐出来的放到命令行的最后。xargs的占位符就发挥作用了，将上面的命令修改</p><pre><code class="sh">ls *.log | xargs -I {} cp {}  /var/log/</code></pre><p>通过  <code>-I</code>参数指定大括号为占位符，cp后的大括号就是xargs 吐出来的文件名。这里不一定使用大括号，也可指定其他的符号。  <code>-i</code>默认的占位符就是大括号</p><pre><code class="sh">ls *.log | xargs -i cp {} /var/log/</code></pre><p>xargs还有一个-P的参数，是指定xargs同时处理多少个命令。但是感觉没什么效果。例子  <code>ls *.log | xargs -P 8 -i cp {} /var/log/</code></p><p>xargs 的使用就讲到这里</p><h2 id="jq">  <a href="#jq" class="headerlink" title="jq"></a>jq</h2><p>jq 命令并不是Linux系统自带的，所以我们需要格外安装。  <a href="https://stedolan.github.io/jq/download/" target="_blank" rel="noopener">下载的地址</a></p><p>jq 的官方说法是jq is like  <code>sed</code> for JSON data - you can use it to slice and filter and map and transform  structured data with the same ease that  <code>sed</code>,  <code>awk</code>,  <code>grep</code> and friends let you play with text。使用jq在Linux系统上去处理json是非常方便的。比如在终端上curl一个接口，返回一个json，这个json可能很长，我只想看其中部分数据，就可以用上jq了。</p><p>jq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。哈哈哈</p><p>  <a href="https://stedolan.github.io/jq/tutorial/" target="_blank" rel="noopener"> 官方教程</a></p><h2 id="自己实践的例子">  <a href="#自己实践的例子" class="headerlink" title="自己实践的例子"></a>自己实践的例子</h2><p>前段时间有需要将两万张的照片去发起请求，然后处理curl返回的结果。利用了xargs和jq。将命令贴出来记录一下。</p><pre><code class="sh">ls TP | xargs -i -n1 curl -s -F img=@TP/{} http://127.0.0.1:9001/faceid/v1/liveness_cfg                                                                 | jq -c -r &#39;[.liveness.mask,.liveness.replay,.liveness.graphics]&#39; &gt; TP.txt &amp;</code></pre><p>TP就是有两万张照片的文件夹，将请求的结果通过jq处理，然后输出到TP.txt文件 中</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>caddy的简易使用</title>
    <link href="/2017/06/30/caddy%E7%9A%84%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2017/06/30/caddy%E7%9A%84%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>​ caddy是一个开源的，使用golang 编写，支持HTTPS的web服务器，同时也可以作为负载均衡器使用，caddy的使用非常简单，只要一个二进制包就可以执行，不用像nginx  配置起来那么麻烦。</p><p>​  <a href="https://caddyserver.com/download" target="_blank" rel="noopener">caddy下载</a></p><p>​ caddy可以使用命令行参数的方式去执行，也可以指定配置文件去执行。使用命令行去执行，具体的参数名称参考  <a href="https://caddyserver.com/docs/cli" target="_blank" rel="noopener">caddy 接收参数</a></p><p>​ caddy在某个文件夹下直接执行，通过访问  <a href="http://localhost:2015访问文件下的所有内容。使用起来非常简单。" target="_blank" rel="noopener">http://localhost:2015访问文件下的所有内容。使用起来非常简单。</a></p><h3 id="使用">  <a href="#使用" class="headerlink" title="使用"></a>使用</h3><p> 通过配置文件来使用caddy，执行是  <code>caddy -conf caddyfile</code>, 给caddy 配置不同的caddyfile如下</p><ul>  <li>    <p>使用caddy 负载均衡，配置caddyfile</p>    <pre><code class="sh">:1234proxy / ip1:port1,ip2:port2,ip3:port3{  policy random  health_check /version  health_check_interval 30s  health_check_timeout 30s}log ／ /var/log/caddy.log {    rotate_size    100    rotate_age      7    rotate_keep     5}</code></pre>    <p>注：caddy监听本机      <code>1234</code>端口，分别将请求转发给      <code>ip1:port1,ip2:port2,ip3:port3</code> 三台机器，policy为负载均衡的策略，random表示从三台机器上随机选择负载，也有其他选项least_conn,      round_robin, first, ip_hash, or uri_hash。      <code>health_check</code>是对三台机器提供的服务进行健康检查，/version 为进行健康检查的接口。每30秒进行一次健康检查，每次检查超过30秒表示失败。如果发现这个接口不能正常返回，则回被caddy标识为不健康的服务，则后续的负载不会到不健康的服务上。配置log记录caddy日志信息</p>  </li></ul><a id="more"></a><ul>  <li>    <p>使用caddy作为静态资源服务器，配置caddyfile</p>    <pre><code class="sh">:1234root /opt/testbrowseext .pdf .html .htm</code></pre>    <p> 注：caddy监听本机的      <code>1234</code>端口，指定了访问的根目录为/opt/test,如果/opt/test 目录下没有index.html,那么访问      <code>http://ip:1234</code> 会将/opt/test目录结构展现到页面中。ext 表示可以忽略文件的后缀</p>  </li></ul><p>更多的配置可以访问  <a href="https://caddyserver.com/docs/http-caddyfile" target="_blank" rel="noopener">caddy配置文件</a></p>]]></content>
    
    
    <categories>
      
      <category>开源工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公众号开发前端</title>
    <link href="/2017/06/19/%E5%85%AC%E4%BC%97%E5%8F%B7web%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2017/06/19/%E5%85%AC%E4%BC%97%E5%8F%B7web%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>上一篇讲了微信公众号后端的开发，这一篇是讲讲前端页面的开发。前端的技术栈用的是react。这里介绍了在开发过程中遇到的一些问题。以及一些知识点的介绍</p><p>以下步骤的前提是你已经安装了node，才能继续往下走。</p><h2 id="创建一个node工程">  <a href="#创建一个node工程" class="headerlink" title="创建一个node工程"></a>创建一个node工程</h2><p>​ 初始化一个工程，并进行一些基本信息填写。执行  <code>npm init</code>，根据提示填写信息，最后会生成一个package.json 文件。这样一个node工程初始化完成了。以下package.json  文件是我修改过的，默认生成的文件和这个是有差异的。主要讲解几个字段，main:表示入口文件，scripts：主要是脚本命令，执行npm start 的时候，它会执行scripts  下start 后的命令，dependencies：是工程依赖的一些库，devDependencies：主要是开发的时候使用的一些库，生产的时候不需要使用。</p><a id="more"></a><pre><code class="json">{  &quot;name&quot;: &quot;doudou-client&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;wechat public&quot;,  &quot;main&quot;: &quot;app.js&quot;,  &quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;,    &quot;dev&quot;: &quot;webpack -d --watch&quot;  },  &quot;author&quot;: &quot;cocoon&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: {  },  &quot;devDependencies&quot;: {    &quot;webpack&quot;: &quot;^1.12.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^1.12.1&quot;  }}</code></pre><p>​ 有一个package.json 文件还不能使用，接下来是编写app.js文件，也就是入口文件，我们就简易的写一个demo文件吧！我们要使用react进行开发我们就得安装reactjs  相关的依赖，执行以下命令来添加reactjs 依赖的库,和开发时使用的一些开发库。如：webpack</p><pre><code class="sh">npm install --save react react-domnpm install --save-dev css-loadernpm install --save-dev style-loadernpm install --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-reactnpm install --save-dev webpack webpack-dev-server</code></pre><p>创建一个app.js文件</p><pre><code class="jsx">import React, { Component } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;class App extends Component {    render() {           return (               &lt;div&gt;hello wechat test&lt;/div&gt;           );       }}ReactDOM.render((       &lt;App/&gt;), document.getElementById(&#39;container&#39;));</code></pre><p>​ 除了js文件之外，我们还需要一个 html文件，来加载这些js文件。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css&quot; /&gt;    &lt;title&gt;微信公众号网页&lt;/title&gt;    &lt;script&gt;        function setHeight() {            console.log(screen.height)            document.body.style.height = screen.height + &#39;px&#39;;        }    &lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;width: 100%;&quot; onload=&quot;setHeight()&quot;&gt;&lt;div id=&quot;container&quot; id=&quot;container&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./assets/vendor.bundle.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./assets/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>​ 发现我们的html页面中并没有加载app.js文件，是因为我们通过webpack 来打包js文件，css文件，图片等。html页面加载的是我们打包之后的文件。所以我们在工程目录下创建一个webpack.config.js文件，来配置webpack一些打包的配置项</p><pre><code class="js">var webpack = require(&#39;webpack&#39;);var path = require(&#39;path&#39;);var autoprefixer = require(&#39;autoprefixer&#39;);var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);var OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;);module.exports = {    entry: {        js: [&#39;./app.js&#39;],        vendor: [&#39;react&#39;, &#39;classnames&#39;, &#39;react-router&#39;, &#39;react-dom&#39;, &#39;react-addons-css-transition-group&#39;]    },    output: {        path: path.resolve(__dirname, &#39;dist&#39;),        filename: &#39;./bundle.js&#39;    },    devServer:{        proxy:{            &#39;/api&#39;:{                target:&#39;http://localhost:5000&#39;,                secure: false,                changeOrigin: true,                pathRewrite: {&#39;^/api&#39;: &#39;&#39;}            }        },    },    module: {        loaders: [            {                test: /\.js[x]?$/,                exclude: /node_modules/,                loader: &#39;babel&#39;,                query: {                    cacheDirectory: true,                    presets: [&#39;es2015&#39;, &#39;react&#39;]                }            }, {                test: /\.less$/,                loader: &#39;style!css!postcss!less&#39;            }, {                test: /\.css/,                loader: ExtractTextPlugin.extract(&#39;style&#39;, &#39;css&#39;, &#39;postcss&#39;)            }, {                test: /\.(png|jpg|svg)$/,                loader: &#39;url?limit=25000&#39;            }        ]    },    postcss: [autoprefixer],    plugins: [        new webpack.DefinePlugin({            DEBUG: process.env.NODE_ENV !== &#39;production&#39;        }),        new ExtractTextPlugin(&#39;weui.min.css&#39;),        new webpack.optimize.CommonsChunkPlugin(&#39;vendor&#39;, &#39;vendor.bundle.js&#39;),        new HtmlWebpackPlugin({            template: path.join(__dirname, &#39;./index.html&#39;)        }),    ]};</code></pre><p>​ 更多的webpack学习，请移步  <a href="https://zhaoda.gitbooks.io/webpack/content/" target="_blank" rel="noopener">webpack学习入门</a></p><p>整个工程demo在GitHub上  <a href="https://github.com/Cocoon-break/wechat_public_template" target="_blank" rel="noopener">wechat_public_template</a></p><h2 id="常规问题">  <a href="#常规问题" class="headerlink" title="常规问题"></a>常规问题</h2><ul>  <li>    <p>网页无法适应全屏？</p>    <p>在开发过程中发现body标签高度始终无法全屏，及时设置高度为100%，也无法生效。</p>    <pre><code class="html">&lt;!--1.添加移动适配设置 --&gt;&lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;&lt;!--2.添加js动态的把body高度设置为，设备屏高--&gt;&lt;script&gt;        function setHeight() {            document.body.style.height = screen.height + &#39;px&#39;;        }&lt;/script&gt;&lt;!--3.在body onload 时执行js--&gt;&lt;body style=&quot;width: 100%;&quot; onload=&quot;setHeight()&quot;&gt;&lt;/body&gt;</code></pre>  </li></ul><h2 id="开源库使用时遇到的问题">  <a href="#开源库使用时遇到的问题" class="headerlink" title="开源库使用时遇到的问题"></a>开源库使用时遇到的问题</h2><ul>  <li>    <p>在使用react-weui 发现样式无法生效</p>    <pre><code class="js">import &#39;react-weui/lib/react-weui.min.css&#39;;//导入对应样式文件</code></pre>  </li>  <li>    <p>在使用fontawesome 时，发现图标无法显示</p>    <pre><code class="html"> &lt;!--在html中把样式文件加上--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;&gt;</code></pre>  </li>  <li>    <p>开发时想通过fetch直接请求服务端接口，解决跨域问题</p>    <pre><code class="js">//package.json 使用webpack-dev-server 启动开发环境，重点是-d&quot;scripts&quot;:{  &quot;start&quot;: &quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;,}//webpack.config.js 配置代理  module.exports = {    //其他配置省略    devServer:{        proxy:{            &#39;/api&#39;:{                target:&#39;http://localhost:5000&#39;,                secure: false,                changeOrigin: true,                pathRewrite: {&#39;^/api&#39;: &#39;&#39;}            }        },    },  }//使用时代码  fetch(&#39;/api/show_operation/1&#39;)            .then(response=&gt;response.json())            .then(result=&gt;console.log(result))//说明：通过proxy配置可以最终发出的请求路径为http://localhost:500/show_operation/1</code></pre>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 开发服务端</title>
    <link href="/2017/06/19/python%20%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <url>/2017/06/19/python%20%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>最新在开发微信公众号，选择了python做为后端开发的语言。之所以选择python作为开发语言，是因为python开发起来比较快，而且也容易上手。选用的python版本是python2.7.13</p><h2 id="先了解下python的一些基本知识">  <a href="#先了解下python的一些基本知识" class="headerlink" title="先了解下python的一些基本知识"></a>先了解下python的一些基本知识</h2><ul>  <li>    <p>在mac 上执行      <code>pip install xxx</code>会把包安装到哪里？</p>    <p>如果Mac上装了多个版本的Python，可以同过      <code>python --version</code>查看，然后会将包安装到      <code>/usr/local/lib/pythonxxx/site-packages</code>下</p>  </li>  <li>    <p>创建虚拟开发环境</p>    <p>在使用Python开发的时候，各个应用所需的Python版本可能不同，这时我们就需要一个独立的Python开发环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>    <ul>      <li>        <p>安装virtualenv</p>        <pre><code class="sh">pip install virtualenv</code></pre>      </li>      <li>        <p>创建一个目录并创建一个独立的Python环境venv</p>        <pre><code class="sh">mkdir testPythoncd testPythonvirtualenv --no-site-packages venv</code></pre>        <p>          <strong>注：</strong> 参数          <code>--no-site-packages</code>，不会将系统已安装的第三方包复制过来，这样我们就得到一个干净的Python开发环境</p>      </li>      <li>        <p>使用这个venv环境</p>        <pre><code class="sh">source venv/bin/activate</code></pre>        <p>接下来          <code>pip install xxx</code> 都会把Python包放在          <code>testPython/venv/lib/python2.7/site-packages</code>目录下</p>      </li>      <li>        <p>离开venv 环境</p>        <pre><code class="sh"> deactivte</code></pre>      </li>    </ul>    <p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令      <code>source venv/bin/activate</code>进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令      <code>python</code>和      <code>pip</code>均指向当前的virtualenv环境。</p>  </li></ul><p>​  <strong>注：</strong> 使用venv 环境之后，执行  <code>pip install xxxx</code> ，它会把这些依赖包安装在  <code>venv/lib/python2.7/site-packages</code>目录下</p><ul>  <li>    <p>依赖第三方库的统一配置文件      <strong>requirements.txt</strong>    </p>    <pre><code class="text">Flask==0.12</code></pre>    <p>通过      <code>pip install -r requirements.txt</code>来安装文件中依赖的一些第三方库</p>  </li></ul><a id="more"></a><h2 id="项目开发">  <a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>flask是python的一个轻量级Web应用框架，对于一些小的站点来说flask，已经能够满足需求了。执行  <code>pip install flask</code>安装。  <a href="http://flask.pocoo.org/" target="_blank" rel="noopener">flask 官网</a></p><p>创建一个run.py文件，写如以下代码。然后执行python run.py，一个简易的web服务就OK了。访问localhost:8080端口</p><pre><code class="python">from flask import Flask, requestapp = Flask(__name__)@app.route(&#39;/test&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def test():    return jsonify({&#39;msg&#39;:&#39;hello world&#39;})if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, port=8080)</code></pre><p>链接数据库使用的sqlalchemy, sqlalchemy 是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。  <a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy官网</a></p><ul>  <li>    <p>本地机器已经安装了mysql，但是在使用sqlalchemy 报No module named mysql。</p>    <pre><code class="python"> pip install pymysql</code></pre>  </li>  <li>    <p>链接数据库样例</p>    <pre><code class="python"> from sqlalchemy import Column, String, create_engine # 初始化数据库连接: engine = create_engine(&#39;mysql+pymysql://&#39;+username+&#39;:&#39;+password+&#39;@localhost:3306/doudouSpace&#39;) def create_user_table():     connect = engine.connect()     try:         result = connect.execute(&#39;xxxx&#39;) #xxx 表示sql语句         result.close()     except Exception as e:         print e</code></pre>    <p>      <strong>注：</strong>更多详细文档请参考官网</p>  </li></ul><p>日志模块也是开发工作中的一个重要部分，可以方便我们调试开发。我们使用python自带的logging模块，我们要将日志信息输出到文件中，而不是只输出到控制台中。</p><ul>  <li>    <p>封装下日志模块</p>    <pre><code class="python">import loggingfrom logging.handlers import RotatingFileHandlerfrom . import configlog_filename = &#39;output.log&#39;logging.basicConfig(level=logging.DEBUG,                    format=&#39;%(filename)s:%(lineno)s - %(asctime)s %(levelname)s %(message)s&#39;,                    filename=log_filename,                    filemode=&#39;a&#39;)logger = logging.getLogger()log_handler = logging.handlers.WatchedFileHandler(log_filename)logger.addHandler(log_handler)def debug(msg):    # logging.debug(msg)    logger.debug(msg)def info(msg):    # logging.info(msg)    logger.info(msg)def warning(msg):    # logging.warning(msg)    logger.warning(msg)def error(msg):    # logging.error(msg)    logger.error(msg)</code></pre>    <p>其他的一些在这里就不在过多的介绍了，我做了一个python开发后端rest接口的模版工程，放在GitHub上，有兴趣的话可以看看      <a href="https://github.com/Cocoon-break/python_tmplate" target="_blank" rel="noopener">python_tmplate</a>    </p>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RN 中使用mobx来进行状态管理</title>
    <link href="/2017/06/13/RN%E4%B8%AD%E4%BD%BF%E7%94%A8mobx%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2017/06/13/RN%E4%B8%AD%E4%BD%BF%E7%94%A8mobx%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在使用RN开发app过程中需要状态管理，也就是state 这个概念，由此衍生出来的两个状态管理的框架，一个是redux，另一个就是mobx了。这两个我都用过，今天就先来介绍下mobx  在开发RN中的使用。实际上不使用状态管理的框架，你也是能够进行开发的，但是随着项目的开发以及项目的壮大，会发现没有状态管理，这个工程越来越难维护。当然redux和mobx也都是可以使用在react的web项目中。</p><p>mobx核心的理念是  <strong>动作</strong>改变  <strong>状态</strong>，而状态的改变会更新所有受影响的  <strong>视图</strong>，通俗来讲，一个应用可以拥有一个大的state，而每一个页面都和这个这个state相关连，通过改变这个state来更新页面。当然一个应用可以拥有多个state不一定是一个，这个开每个开发者对项目的规划。举个例子：用户的state,在用户未登录时，页面的显示时登录界面，当用户点击登录时，通过更新这个state，来更新这个view。更多的mobx概念请移步  <a href="http://cn.mobx.js.org/" target="_blank" rel="noopener">mobx中文文档</a></p><p>接下来就是在实际开发中使用mobx了</p><a id="more"></a><ul>  <li>    <p>在package.json 引入</p>    <pre><code class="js">&quot;dependencies&quot;: {    &quot;mobx&quot;: &quot;^2.6.1&quot;,    &quot;mobx-react&quot;: &quot;^3.5.8&quot;,    //其他库}//不加这个装饰器使用不了，如@action   &quot;devDependencies&quot;: {  &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;}</code></pre>  </li>  <li>    <p>.babelrc 中添加</p>    <pre><code class="js">{  &quot;presets&quot;: [&quot;react-native&quot;],  &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;] //在babel转义的时候能够将装饰器转义}</code></pre>  </li></ul><h3 id="创建一个简易的计数器">  <a href="#创建一个简易的计数器" class="headerlink" title="创建一个简易的计数器"></a>创建一个简易的计数器</h3><ul>  <li>    <p>创建一个一个store</p>    <pre><code class="js">import {observable, action, computed, toJS} from &#39;mobx&#39;class mobxStore {    @observable count = 0    @action addCount() {        this.count = this.count + 1;    }    @action reduceCount() {        this.count = this.count - 1;    }}const store = new mobxStore()export default store</code></pre>  </li>  <li>    <p>在界面中和store 关联</p>    <pre><code class="javascript">import React, {Component} from &#39;react&#39;;import {    Text,    StyleSheet,    TouchableHighlight,    View} from &#39;react-native&#39;;import {observer} from &#39;mobx-react/custom&#39;import store from &#39;./mobxStore&#39;@observerclass Root extends Component {    render() {        return (            &lt;View style={styles.container}&gt;                &lt;Text style={styles.welcome}&gt;                    Mobx 的简易使用demo                &lt;/Text&gt;                &lt;Text style={styles.instructions}&gt;                    store中的计数器：{store.count}                &lt;/Text&gt;                &lt;TouchableHighlight style={{marginTop: 8}} onPress={() =&gt; store.addCount()}&gt;                    &lt;Text style={styles.instructions}&gt;                        点击计数+1                    &lt;/Text&gt;                &lt;/TouchableHighlight&gt;                &lt;TouchableHighlight style={{marginTop: 8}} onPress={() =&gt; store.reduceCount()}&gt;                    &lt;Text style={styles.instructions}&gt;                        点击计数-1                    &lt;/Text&gt;                &lt;/TouchableHighlight&gt;            &lt;/View&gt;        );    }}const styles = StyleSheet.create({    container: {        flex: 1,        justifyContent: &#39;center&#39;,        alignItems: &#39;center&#39;,        backgroundColor: &#39;#F5FCFF&#39;,    },    welcome: {        fontSize: 20,        textAlign: &#39;center&#39;,        margin: 10,    },    instructions: {        textAlign: &#39;center&#39;,        color: &#39;red&#39;,        marginBottom: 5,    },});export default Root</code></pre>  </li></ul><p>导入  <code>import {observer} from &#39;mobx-react/custom&#39;</code> 和刚才创建的store，  <code>import store from &#39;./mobxStore&#39;</code></p><p>demo 的源码已经放到github上  <a href="https://github.com/Cocoon-break/mobxDemo" target="_blank" rel="noopener">mobxDemo</a>，如有疑问请在该仓库中提issue</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react-native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各个平台上传图片</title>
    <link href="/2017/06/13/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2017/06/13/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>开发时常遇到的一些上传图片操作，这里记录一下。包括android，iOS，和java后端，后面还遇到的其他语言或平台时，会进行补充</p><p>android AsyncHttpClient 上传图片,要使用  <a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">android-async-http</a></p><pre><code class="java">public void uploadImg(String filePath) {        AsyncHttpClient asyncHttpclient = new AsyncHttpClient();        RequestParams params = new RequestParams();        try {            params.put(&quot;liveness&quot;, &quot;1&quot;);            params.put(&quot;img&quot;, new File(filePath));// 传入照片路径        } catch (FileNotFoundException e) {            e.printStackTrace();        }        String url = &quot;&quot;;        asyncHttpclient.post(url, params, new AsyncHttpResponseHandler() {            @Override            public void onSuccess(int statusCode, Header[] headers,                                  byte[] responseByte) {                String successStr = new String(responseByte);                try {                    JSONObject jObject = new JSONObject(successStr)                            .getJSONArray(&quot;faces&quot;).getJSONObject(0);                  //其他省略                } catch (JSONException e) {                    e.printStackTrace();                }            }            @Override            public void onFailure(int statusCode, Header[] headers,                                  byte[] responseBody, Throwable error) {                // 上传失败            }        });    }</code></pre><a id="more"></a><p>iOS NSMutableURLRequest上传图片，NSMutableURLRequest是oc自带库</p><pre><code class="objective-c">- (void) uploadImage:(NSData *)imageData{    //字典里面装的是你要上传的内容    NSDictionary *parameters = @{@&quot;liveness&quot;: @&quot;1&quot;};    //上传的接口    NSString* urlstring = @&quot;http://132.121.1.213:9000/faceid/v1/extract&quot;;    //分界线的标识符    NSString *TWITTERFON_FORM_BOUNDARY = @&quot;AaB03x&quot;;    //根据url初始化request    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]                                                            cachePolicy:NSURLRequestReloadIgnoringLocalCacheData                                                        timeoutInterval:10];    //分界线 --AaB03x    NSString *MPboundary=[[NSString alloc]initWithFormat:@&quot;--%@&quot;,TWITTERFON_FORM_BOUNDARY];    //结束符 AaB03x--    NSString *endMPboundary=[[NSString alloc]initWithFormat:@&quot;%@--&quot;,MPboundary];    //    //要上传的图片    //    UIImage *image=[params objectForKey:@&quot;pic&quot;];    //得到图片的data    //    NSData *data = UIImagePNGRepresentation(self.image);    //http body的字符串    NSMutableString *body=[[NSMutableString alloc]init];    //参数的集合的所有key的集合    NSArray *keys= [parameters allKeys];    //遍历keys    for(int i=0;i&lt;[keys count];i++)    {        //得到当前key        NSString *key=[keys objectAtIndex:i];        //如果key不是img，说明value是字符类型，比如name：Boris        if(![key isEqualToString:@&quot;img&quot;])        {            //添加分界线，换行            [body appendFormat:@&quot;%@\r\n&quot;,MPboundary];            //添加字段名称，换2行            [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;,key];            //添加字段的值            [body appendFormat:@&quot;%@\r\n&quot;,[parameters objectForKey:key]];        }    }    ////添加分界线，换行    [body appendFormat:@&quot;%@\r\n&quot;,MPboundary];    //声明img字段，文件名为boris.png    [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;img\&quot;; filename=\&quot;boris.png\&quot;\r\n&quot;];    //声明上传文件的格式    [body appendFormat:@&quot;Content-Type: image/png\r\n\r\n&quot;];    //声明结束符：--AaB03x--    NSString *end=[[NSString alloc]initWithFormat:@&quot;\r\n%@&quot;,endMPboundary];    //声明myRequestData，用来放入http body    NSMutableData *myRequestData=[NSMutableData data];    //将body字符串转化为UTF8格式的二进制    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];    //将image的data加入    [myRequestData appendData:imageData];    //加入结束符--AaB03x--    [myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];    //设置HTTPHeader中Content-Type的值    NSString *content=[[NSString alloc]initWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,TWITTERFON_FORM_BOUNDARY];    //设置HTTPHeader    [request setValue:content forHTTPHeaderField:@&quot;Content-Type&quot;];    //设置Content-Length    [request setValue:[NSString stringWithFormat:@&quot;%d&quot;, (int)[myRequestData length]] forHTTPHeaderField:@&quot;Content-Length&quot;];    //设置http body    [request setHTTPBody:myRequestData];    //http method    [request setHTTPMethod:@&quot;POST&quot;];    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) {        if(data.length &gt; 0)        {        }    }];}</code></pre><p>java中使用httpClient 上传文件</p><p>pom.xml 中添加 httpclient</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;  &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;  &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code class="java"> public static String postWithFormData(String url, Map map) {        HttpClient client = new HttpClient();        PostMethod postMethod = new PostMethod(url);        try {             String imgPath = (String) map.get(&quot;img&quot;);            FilePart imgpart = null;            if (imgPath != null &amp;&amp; !imgPath.equals(&quot;&quot;)) {               imgpart = new FilePart(&quot;img&quot;, new File(imgPath));            }            StringPart stringPart = new StringPart(&quot;liveness&quot;, &quot;1&quot;);            Part[] parts = {imgpart, stringPart};            MultipartRequestEntity multipartRequestEntity = new MultipartRequestEntity(parts, new HttpMethodParams());            postMethod.setRequestEntity(multipartRequestEntity);            int statusCode = client.executeMethod(postMethod);            if (statusCode != 200) {                Map map1 = new HashMap();                map1.put(&quot;msg&quot;, &quot;http 请求错误&quot;);                return new JSONObject(map1).toString();            }            InputStream inputStream = postMethod.getResponseBodyAsStream();            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));            String line = &quot;&quot;;            StringBuilder sb = new StringBuilder();            while ((line = reader.readLine()) != null) {                sb.append(line + &quot;\n&quot;);            }            inputStream.close();            return sb.toString();        } catch (IOException e) {            e.printStackTrace();            return &quot;&quot;;        }    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm,tmux,vim 的常用快捷键</title>
    <link href="/2017/06/02/iterm,tmux,vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2017/06/02/iterm,tmux,vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>上一篇博客我们搭建了Mac下流畅的终端使用环境，这篇博客我们讲一些常用的快捷键来提高开发效率。废话不多说我们开始吧</p><h2 id="iterm2-快捷">  <a href="#iterm2-快捷" class="headerlink" title="iterm2 快捷"></a>iterm2 快捷</h2><p>通常我们在使用时，一个窗口总是感觉不够用，这时我们就需要多窗口，或者一个窗口需要多个屏。打开Iterm2，我们按下  <code>command + t</code>，来新建窗口，通过  <code>commmand + w</code>来关闭当前窗口，如果我们想要切换不同的窗口时，我们可以通过  <code>command + 方向键</code> 或者  <code>command + 数字</code>来切换窗口。  <code>command + q</code> 退出应用程序</p><p>  <strong>注：</strong>  <code>command + t</code>或者  <code>command + w</code>或者  <code>command +q</code> 在很多应用都是通用的,比如在chrom 上，这几个快捷键，分别表示新建tab页，关闭tab页，推出chrom。但是chrom  切换tab是使用  <code>command + option +方向键</code> 这个就和iterm2有区别了。</p><p>在链接远程服务器时，我需要在同一窗口，查看不同服务器的状态，或者其他的一些信息。多窗口去查看就太麻烦 了。iterm 的分屏就能满足你的需要了。iterm2在分屏时，可以进行横向分屏和纵向分屏。纵向分屏使用  <code>command + d</code>横向分屏使用  <code>command + shift +d</code>，关闭当前分屏的快捷键也是使用  <code>command + w</code>，切换各个分屏使用的是  <code>command + option + 方向键</code>，以下是效果图</p><a id="more"></a><p>  <img src="https://cocoon-break.github.io/images/screenShot/iterm2_keymap.jpg" srcset="/img/loading.gif" alt></p><p>接下来就是在输入的时候，我们需要快速回到行首使用  <code>ctrl + a</code>，快速回到行末使用  <code>ctrl + e</code>，输入失误就需要删除错误了，  <code>ctrl + u</code>是将当前行清空，使用  <code>ctrl + w</code>,删除光标之前的单词，使用  <code>ctrl + h</code>删除光标之前所有字符，使用  <code>ctrl + k</code> 删除光标之后的所有字符。</p><p>总结下 ：</p><ul>  <li>窗口和屏相关    <ul>      <li>新建窗口：command + t</li>      <li>关闭窗口或者分屏：command + w</li>      <li>切换标签：command + 左右方向键</li>      <li>切换全屏：command + enter</li>      <li>水平分屏：command + shift + d </li>      <li>垂直分屏：command + d </li>      <li>切换分屏：command + option + 方向键</li>    </ul>  </li>  <li>编辑相关    <ul>      <li>清除当前行：ctrl + u</li>      <li>删除光标之前的字符：ctrl + h</li>      <li>删除光标之前的单词：ctrl + w</li>      <li>删除光标到文本末尾：ctrl + k</li>      <li>到行首： ctrl + a</li>      <li>到行末：ctrl + e</li>    </ul>  </li></ul><h2 id="tmux-快捷键">  <a href="#tmux-快捷键" class="headerlink" title="tmux 快捷键"></a>tmux 快捷键</h2><p> 打开iterm2 输入  <code>tmux</code> 就进入了tmux的交互模式了，tmux 也有窗口和屏的概念这里就不再说明了。直接进入主题，快捷键的使用。</p><p>在使用任何功能时我们都得先按下  <code>ctrl + b</code> 然后  <strong>松开</strong>，接着按下其他的键，比如我要新建一个窗口，先按下  <code>ctrl + b</code> 然后在按下  <code>c</code>, 这就完成了窗口的新建。</p><ul>  <li>快捷键都是先按下    <code>ctrl + b</code>然后在按一下键    <ul>      <li>c 新建窗口</li>      <li>&amp; 关闭当前窗口</li>      <li>p 切换至上一个窗口</li>      <li>n 切换至下一个窗口</li>      <li>% 将当前窗口纵向分屏</li>      <li>“ 将当前窗口横向分屏</li>      <li>方向键 在多个分屏中切换</li>      <li>d 脱离当前tmux，在输入tmux attach 就能重新进入</li>      <li>z 使当前屏占满全屏，在次按下则恢复之前屏样式</li>      <li>x 关闭当前屏</li>      <li>alt + 方向键 调整当前屏大小</li>    </ul>  </li></ul><p>这里只将一些基础的快捷键，更多快捷键和配置，请自行谷歌，百度，以下为tmux 分屏之后的效果图</p><p>  <img src="https://cocoon-break.github.io/images/screenShot/iterm2_tmux_keymap.jpg" alt></p><h2 id="vim-快捷键">  <a href="#vim-快捷键" class="headerlink" title="vim 快捷键"></a>vim 快捷键</h2><p>vim 的功能很强大，这里也不会深入讲解介绍，只是收集了一些快捷键，以便提供一些效率。</p><ul>  <li>查找    <ul>      <li>从光标处向下搜索：/ + 要查找的词</li>      <li>从光标处向上搜索：? + 要查找的词</li>      <li>快速回到页首：{</li>      <li>去页尾：}</li>      <li>回行首：shift + ^</li>      <li>回行末：shift + $</li>    </ul>  </li>  <li>编辑    <ul>      <li>删除光标出的字母：x</li>      <li>删除光标所在行：dd</li>      <li>删除单词包括空格：dw</li>      <li>回撤上一次编辑：u </li>      <li>取消撤回功能(对u功取消)：control + r</li>      <li>复制光标所在行：yy</li>      <li>复制n(数字)行：nyy</li>      <li>复制单词：yw</li>      <li>复制n个单词：nyw</li>      <li>复制光标所在位置到行末：y$</li>      <li>复制光标所在位置到行首：y^</li>      <li>粘贴：p</li>    </ul>  </li></ul><p>更多vim 操作快捷键：  <a href="http://www.lcode.cc/2017/04/10/vim-shortcut-key.html" target="_blank" rel="noopener">vim快捷键</a></p><p>这篇博客只是收集和介绍一些基础简单的快捷键，并没有很深入的去使用iterm2 ，tmux，vim，这些功能都很强大，想继续深入的同学可以去查查资料。</p>]]></content>
    
    
    <categories>
      
      <category>开发效率</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下打造流畅的终端使用环境</title>
    <link href="/2017/05/27/Mac%E4%B8%8B%E6%89%93%E9%80%A0%E6%B5%81%E7%95%85%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83/"/>
    <url>/2017/05/27/Mac%E4%B8%8B%E6%89%93%E9%80%A0%E6%B5%81%E7%95%85%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>作为程序员Mac上自带的终端是远远满足不了我们的，这时我们就要自己手动搭一个我们顺手的终端环境。下面我们就来搭建iterm2+ oh my zsh + tmux  的终端工具</p><h2 id="ITerm2-安装">  <a href="#ITerm2-安装" class="headerlink" title="ITerm2 安装"></a>ITerm2 安装</h2><ol>  <li>    <p>上Iterm2的官网下载iterm2,      <a href="http://www.iterm2.com/" target="_blank" rel="noopener">iterm2下载</a>    </p>  </li>  <li>    <p>下载完成之后，发现iterm2 自带的配色我不太喜欢，安装完成之后进行item2的配色，这个纯属看个人喜好了。</p>    <ul>      <li>        <p>要进行配色，我们当然得要有配色的方案啦！什么你要自己配一个，嗯…… 这也是可以的，不过有很多现成的方案你要不要啊。github 上有超多的配色方案，我们先把这个库给clone下来。</p>        <pre><code class="sh">git clone git@github.com:mbadolato/iTerm2-Color-Schemes.git</code></pre>        <p>要是你没有git，那我觉得你没太必要继续下去了。当然你还想继续的话，你就上GitHub手动download 下来。</p>        <a id="more"></a>      </li>      <li>        <p>好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git          克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案，这就看个人喜好了哈，这样你的iterm2配色方案就完成了</p>        <p>          <img src="https://cocoon-break.github.io/images/screenShot/iterm2_color.jpg" alt>        </p>      </li>    </ul>  </li></ol><h2 id="Mac下shell介绍">  <a href="#Mac下shell介绍" class="headerlink" title="Mac下shell介绍"></a>Mac下shell介绍</h2><p>Shell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。</p><p>Linux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。</p><pre><code class="sh">cat /etc/shells</code></pre><p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，目前常用的 Linux 系统和  OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh，这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看  zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」</p><h3 id="安装使用on-my-zsh">  <a href="#安装使用on-my-zsh" class="headerlink" title="安装使用on-my-zsh"></a>安装使用on-my-zsh</h3><ol>  <li>    <p>通过git 把oh-my-zsh 下载下来</p>    <pre><code class="sh">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre>  </li>  <li>    <p>添加配置文件并设置为默认的shell</p>    <pre><code class="sh">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcchsh -s /bin/zsh</code></pre>    <p>      <strong>注:</strong> .zshrc 就相当于.bashrc了以后配置环境就在.zshrc中配置就行</p>  </li>  <li>    <p>配置oh-my-zsh 的主题</p>    <p>oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考      <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">主题预览</a>，选好主题了，接下来就是配置了。编辑~/.zshrc 文件</p>    <pre><code class="sh">vim ~/.zshrc#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的ZSH_THEME=&quot;af-magic&quot;</code></pre>  </li>  <li>    <p>oh-my-zsh 就配置完了。这里只是简单的介绍oh-my-zsh。oh-my-zsh 功能还是很丰富的，更多oh-my-zsh请移步      <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh GitHub地址</a>    </p>  </li></ol><h2 id="安装tmux">  <a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><p>Tmux 是一个工具，用于在一个终端窗口中运行多个终端会话。不仅如此，你还可以通过 Tmux 使终端会话运行于后台或是按需接入、断开会话，这个功能非常实用。</p><ol>  <li>    <p>先安装Homebrew，这个是Mac平台的包管理器。用来安装一些开发工具还是很方便。Mac系统自带了ruby的环境，我们通过ruby来安装Homebrew</p>    <pre><code class="sh">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre>  </li>  <li>    <p>通过homebrew 安装tmux</p>    <pre><code class="sh">brew install tmux</code></pre>  </li>  <li>    <p>就是这么简单tmux就装完了</p>  </li></ol><p>下一篇会讲具体的使用方法，包括iterm快捷键，tmux的使用</p>]]></content>
    
    
    <categories>
      
      <category>开发效率</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell 脚本中读取参数值</title>
    <link href="/2017/05/25/shell%20%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E5%80%BC/"/>
    <url>/2017/05/25/shell%20%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>shell 脚本中读取参数值</p><p>通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了</p><h2 id="根据参数位置直接获取">  <a href="#根据参数位置直接获取" class="headerlink" title="根据参数位置直接获取"></a>根据参数位置直接获取</h2><ol>  <li>    <p>先定义一个脚本test.sh，打印位置参数</p>    <pre><code class="ssh">#!/bin/bashecho $1echo $2</code></pre>  </li>  <li>    <p>执行test.sh脚本</p>    <pre><code class="ssh">./test.sh haha hehehe</code></pre>    <p>执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。</p>    <a id="more"></a>  </li></ol><h2 id="指定key-获取参数">  <a href="#指定key-获取参数" class="headerlink" title="指定key 获取参数"></a>指定key 获取参数</h2><ol>  <li>    <p>一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义</p>    <pre><code class="ssh">#!/bin/bash#先定义接收各个参数值的变量IP_VALUE=&quot;&quot;; NODE_VALUE=&quot;&quot;;VIP_VALUE=&quot;&quot;;while true;do     if [ ! $2 ]; then break; fi    case $1 in        -i|--ip)            case $2 in            &quot;&quot;)IP_VALUE=&quot;&quot;;shift 2;;            *)IP_VALUE=$2;shift 2;;            esac;;        -n|--node)            case $2 in            &quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;            *)NODE_VALUE=$2;shift 2;;            esac;;        -v|--vip)            case $2 in            &quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;            *)NODE_VALUE=$2;shift 2;;            esac;;         --) shift ;break ;;         *) break;;        esacdoneif [ -z &quot;${IP_VALUE}&quot; ];    then echo &quot;error: ip is not found.&quot;;             exit 1; fiif [ -z &quot;${NODE_VALUE}&quot; ];  then echo &quot;error: node is not found.&quot;;           exit 1; fiif [ -z &quot;${VIP_VALUE}&quot; ];   then echo &quot;error: vip is not found.&quot;;            exit 1; fi</code></pre>    <ul>      <li>通过while 循环参数的$1 和$2 取key 和 value。</li>      <li>case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:        <code>./test.sh -v kkk -n bbbb</code> 读取到如果执行了 shift 2,它就会把-v kkk 给扔了</li>      <li>底下的if 是判断有没有读取到想要的值</li>    </ul>  </li>  <li>    <p>其他的方式去根据key获取参数</p>    <ul>      <li>一个是getopts 但是getopts不支持长选项，具体可以参考        <a href="http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html" target="_blank" rel="noopener">getopts命令行参数处理</a>      </li>      <li>另一个是getopt，        <a href="http://blog.csdn.net/wh211212/article/details/53750366" target="_blank" rel="noopener">shell中使用getopts 和 getopt</a>      </li>    </ul>  </li></ol><p>个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg简易介绍</title>
    <link href="/2017/05/22/ffmpeg%E7%AE%80%E6%98%93%E4%BB%8B%E7%BB%8D/"/>
    <url>/2017/05/22/ffmpeg%E7%AE%80%E6%98%93%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="媒体文件结构">  <a href="#媒体文件结构" class="headerlink" title="媒体文件结构"></a>媒体文件结构</h2><p>一个媒体文件并不像许多人想象的那样，是将媒体内容编码起来直接作为文件的。实际上，它通常是由多个不同种类的媒体流（ Stream ）组成，再以特定的封装格式封装起来的。</p><p>比较常见的媒体流就是视频流跟音频流了，顾名思义，视频流存储的就是视频信息，音频流存储的就是音频信息。一个视频流或者音频流的内容，就是以特定的编码格式所存储的视频或音频信息。</p><p>  <strong>一个文件的里面的媒体流所采用的编码格式跟这个文件的后缀名并没有完全的必然联系。</strong>  <strong>文件的后缀名通常就代表这个文件的封装格式。</strong></p><h2 id="ffmpeg-安装">  <a href="#ffmpeg-安装" class="headerlink" title="ffmpeg 安装"></a>ffmpeg 安装</h2><p>自行下载使用系统安装对应的安装包  <a href="https://ffmpeg.org/download.html" target="_blank" rel="noopener">官网下载</a></p><p>以下使用的平台都为Mac系统下</p><a id="more"></a><h2 id="开始使用">  <a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><ol>  <li>    <p>打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用</p>    <pre><code class="ssh">ffmpeg -help</code></pre>    <pre><code class="ssh">ffmpeg version 3.3 Copyright (c) 2000-2017 the FFmpeg developers  built with Apple LLVM version 8.1.0 (clang-802.0.41)  configuration: --prefix=/usr/local/Cellar/ffmpeg/3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda  libavutil      55. 58.100 / 55. 58.100  libavcodec     57. 89.100 / 57. 89.100  libavformat    57. 71.100 / 57. 71.100  libavdevice    57.  6.100 / 57.  6.100  libavfilter     6. 82.100 /  6. 82.100  libavresample   3.  5.  0 /  3.  5.  0  libswscale      4.  6.100 /  4.  6.100  libswresample   2.  7.100 /  2.  7.100  libpostproc    54.  5.100 / 54.  5.100Hyper fast Audio and Video encoderusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...</code></pre>    <p>重点是关注 usage: ffmpeg [options][[infile options] -i infile]… {[outfile options]      outfile}… 这句是说ffmpeg 的主要用法</p>  </li></ol><ol>  <li>    <p>查看ffmpeg 支持的格式</p>    <p>查看封装格式，包括音频，视频等封装格式</p>    <pre><code class="ssh">ffmpeg -formats</code></pre>    <p>查看编解码器包括音频，视频等封装格式</p>    <pre><code class="ssh">ffmpeg -codecs</code></pre>  </li>  <li>    <p>进行格式转换</p>    <pre><code class="ssh">ffmpeg -i a.mp4 b.mkv</code></pre>    <p>这里是将mp4格式的视频转换成mkv格式。</p>    <p>      <strong>注：</strong> 查看默认编码格式，以下的Matroska也就是指 mkv</p>    <pre><code class="code">ffmpeg -help muxer=Matroska#以下为摘要信息，从中可以看出默认的视频编码为h264,音频编码为ac3,字幕流编码为ass，部分格式视频不支持字幕流Muxer matroska [Matroska]:    Common extensions: mkv.    Mime type: video/x-matroska.    Default video codec: h264.    Default audio codec: ac3.    Default subtitle codec: ass.</code></pre>  </li>  <li>    <p>指定编码器进行转换</p>    <pre><code class="sh">ffmpeg -i a.mp4 -c:v hevc -c:a aac b.mkv</code></pre>    <p>      <strong>注：</strong>      <code>-c:v</code> 可以用      <code>-vcodec</code>替换，当它们的值为copy时，就表示编码格式不进行转换</p>  </li>  <li>    <p>在转换时可以进行的调整</p>    <p>在      <code>ffmpeg -help</code> 时可以看到有一些和音频，视频，字幕相关的选项</p>    <pre><code class="ssh">Video options:-vframes number     set the number of video frames to output-r rate             set frame rate (Hz value, fraction or abbreviation)-s size             set frame size (WxH or abbreviation)-aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)-bits_per_raw_sample number  set the number of bits per raw sample-vn                 disable video-vcodec codec       force video codec (&#39;copy&#39; to copy stream)-timecode hh:mm:ss[:;.]ff  set initial TimeCode value.-pass n             select the pass number (1 to 3)-vf filter_graph    set video filters-ab bitrate         audio bitrate (please use -b:a)-b bitrate          video bitrate (please use -b:v)-dn                 disable dataAudio options:-aframes number     set the number of audio frames to output-aq quality         set audio quality (codec-specific)-ar rate            set audio sampling rate (in Hz)-ac channels        set number of audio channels-an                 disable audio-acodec codec       force audio codec (&#39;copy&#39; to copy stream)-vol volume         change audio volume (256=normal)-af filter_graph    set audio filtersSubtitle options:-s size             set frame size (WxH or abbreviation)-sn                 disable subtitle-scodec codec       force subtitle codec (&#39;copy&#39; to copy stream)-stag fourcc/tag    force subtitle tag/fourcc-fix_sub_duration   fix subtitles duration-canvas_size size   set canvas size (WxH or abbreviation)-spre preset        set the subtitle options to the indicated preset</code></pre>    <p>当然还有对整个文件进行调整的参数</p>    <pre><code class="ssh">Per-file main options:-f fmt              force format-c codec            codec name-codec codec        codec name-pre preset         preset name-map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile-t duration         record or transcode &quot;duration&quot; seconds of audio/video-to time_stop       record or transcode stop time-fs limit_size      set the limit file size in bytes-ss time_off        set the start time offset-sseof time_off     set the start time offset relative to EOF-seek_timestamp     enable/disable seeking by timestamp with -ss-timestamp time     set the recording timestamp (&#39;now&#39; to set the current time)-metadata string=string  add metadata-program title=string:st=number...  add program with specified streams-target type        specify target file type (&quot;vcd&quot;, &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot; or &quot;dv50&quot; with optional prefixes &quot;pal-&quot;, &quot;ntsc-&quot; or &quot;film-&quot;)-apad               audio pad-frames number      set the number of frames to output-filter filter_graph  set stream filtergraph-filter_script filename  read stream filtergraph description from a file-reinit_filter      reinit filtergraph on input parameter changes-discard            discard-disposition        disposition</code></pre>    <p>      <a href="https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh" target="_blank" rel="noopener">文章参考</a>    </p>  </li></ol>]]></content>
    
    
    <categories>
      
      <category>开源工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下打RPM包</title>
    <link href="/2017/05/15/Linux%E4%B8%8B%E6%89%93RPM%E5%8C%85/"/>
    <url>/2017/05/15/Linux%E4%B8%8B%E6%89%93RPM%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>centos 6.5下打rpm包</p><h2 id="工具准备">  <a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ol>  <li>    <p>安装rpmtools工具</p>    <pre><code class="sh">yum install rpmdevtools</code></pre>  </li>  <li>    <p>创建文件夹</p>    <pre><code class="sh">mkdir -pv ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}</code></pre>  </li></ol><h2 id="配置文件及源码准备">  <a href="#配置文件及源码准备" class="headerlink" title="配置文件及源码准备"></a>配置文件及源码准备</h2><ol>  <li>    <p>spec脚本文件创建，在SPECS文件夹下创建一个.spec文件 如h5-megvii.spec</p>    <pre><code class="sh">Name:           h5-megviiLicense:        copyrightVersion:        1.0Release:        1%{?dist}Summary:        HTML FaceID ServerAutoReqProv:    noGroup:          MegviiURL:            http://www.megvii.comSource:         %{name}-%{version}.tar.gzBuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root%descriptionThe rpm version of html-megvii package%prep%setup -q%build%installrm -rf $RPM_BUILD_ROOTmkdir -p $RPM_BUILD_ROOTcp -a * $RPM_BUILD_ROOT%cleanrm -rf $RPM_BUILD_ROOT%files%defattr(-,root,root,-)/opt/megvii</code></pre>    <a id="more"></a>    <p>spec脚本中各个配置项说明</p>    <pre><code class="sh">Name: 软件包的名称，后面可使用%{name}的方式引用License: 软件授权方式Version: 软件的实际版本号,后面可使用%{version}引用Release: 发布序列号,标明第几次打包，后面可使用%{release}引用Summary: 软件包的内容概要AutoReqProv: 此域用于指示RPM是否自动查找软件所需的共享库与其提供的共享库Group: 软件分组URL: 软件的主页Source: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%{source1}、%{source2}引用BuildRoot: 这个是安装或编译时使用的“虚拟目录”,一般定义为:%{_tmppath}/%{name}-%{version}-%{release}-root%description 软件的详细说明%prep 预处理脚本%setup 把源码包解压并放好,将SOURCES下的tar.gz 文件解压至BUILD文件夹下%build 开始构建包%install 开始把软件安装到虚拟的根目录中%clean 清理临时文件%files 定义那些文件或目录会放入rpm中,files下的文件，必须是tar包解压开存在的文件%defattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755</code></pre>    <p>      <strong>注1:</strong> SOURCES下的tar.gz包的文件名必须和SPECS下 xxx.specs 文件中的Source 保持一致。</p>    <p>      <strong>注2:</strong> SOURCES下的tar.gz包      <strong>解压开的文件夹</strong>名称也应为SPECS下 xxx.specs 文件中的Source 对应的名称(无须tar.gz)。</p>    <p>      <strong>注3:</strong> %files标签下的文件路径必须存在，如/opt/megvii ,在tar.gz 解压开的文件路径是存在的</p>  </li>  <li>    <p>添加源码文件</p>    <pre><code class="sh">tar czvf h5-megvii-1.0.tar.gz h5-megvii-1.0cp h5-megvii-1.0.tar.gz rpmbuild/SOURCES/</code></pre>  </li></ol><h2 id="执行打包命令">  <a href="#执行打包命令" class="headerlink" title="执行打包命令"></a>执行打包命令</h2><pre><code class="sh">rpmbuild --nodeps -ba rpmbuild/SPECS/h5-megvii.spec</code></pre><p>打完包之后的rpm包文件位置在  <code>rpmbuild/RPMS</code>文件夹中</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>supervisor linux后台进程管理利器</title>
    <link href="/2017/04/28/supervisor%20%E6%98%AF%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2017/04/28/supervisor%20%E6%98%AF%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>supervisor 是基于python的进程管理工具</p><h2 id="install-online">  <a href="#install-online" class="headerlink" title="install online"></a>install online</h2><ul>  <li>ubuntu 系统安装 apt-get install supervisor</li>  <li>    <p>也可以通过pip install supervisor 但是需要手动启动</p>    <h2 id="install-offline">      <a href="#install-offline" class="headerlink" title="install offline"></a>install offline</h2>  </li>  <li>    <p>下载安装包和依赖包详见官网 [      <a href="https://pypi.python.org/pypi/supervisor" target="_blank" rel="noopener">https://pypi.python.org/pypi/supervisor</a>] 3.3.1版本</p>  </li>  <li>    <p>解压安装tar.gz 然后cd 到目录中执行 python setup.py install</p>  </li>  <li>    <p>创建配置文件</p>  </li>  <li>    <p>执行      <code>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</code>创建配置文件</p>  </li>  <li>    <p>创建supervisord 放在 init.d目录 下      <strong>注：</strong> prog_bin 为supervisors 可执行文件位置</p>    <a id="more"></a>    <pre><code class="ssh"> #!/bin/sh # # /etc/rc.d/init.d/supervisord # # Supervisor is a client/server system that # allows its users to monitor and control a # number of processes on UNIX-like operating # systems. # # chkconfig: - 64 36 # description: Supervisor Server # processname: supervisord # Source init functions . /etc/rc.d/init.d/functions prog=&quot;supervisord&quot; prefix=&quot;/usr&quot; exec_prefix=&quot;${prefix}&quot; prog_bin=&quot;${exec_prefix}/bin/supervisord&quot; PIDFILE=&quot;/var/run/$prog.pid&quot; start() {        echo -n $&quot;Starting $prog: &quot;        touch $PIDFILE        daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE        sleep 1        [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;        echo } stop() {        echo -n $&quot;Shutting down $prog: &quot;        [ -f $PIDFILE ] &amp;&amp; killproc $prog || success $&quot;$prog shutdown&quot;        echo } case &quot;$1&quot; in  start)    start  ;;  stop)    stop  ;;  status)        status $prog  ;;  restart)    stop    start  ;;  *)    echo &quot;Usage: $0 {start|stop|restart|status}&quot;  ;; esac</code></pre>  </li>  <li>    <p>修改指定要运行程序配置文件</p>    <p> 编辑supervisor.conf文件中的</p>    <pre><code> [include] files = /etc/supervisord.conf.d/*.conf</code></pre>    <p>​</p>  </li></ul><h2 id="how-to-use">  <a href="#how-to-use" class="headerlink" title="how to use"></a>how to use</h2><p>在etc/supervisor.conf.d 目录下创建每个进程对应的配置文件 如：work.conf  <br>具体配置  <br>​ directory= /opt/faceid/worker //工程文件目录  <br>​ command= /opt/faceid/worker/start.sh //启动命令  <br>​ autostart=true //是否自启  <br>​ autorestart=true //是否自动重启  <br>​ startretries= 10000 //重试次数  <br>​ startsecs=1 //启动时间  <br>​ stopasgroup=true  <br>​ killasgroup=true``  <br>​ stdout_logfile_maxbytes = 50MB  <br>​ stdout_logfile_backups = 10  <br>​ stdout_logfile = /var/log/megvii/%(program_name)s.log</p><h2 id="common-command">  <a href="#common-command" class="headerlink" title="common command"></a>common command</h2><ul>  <li>supervisorctl status 查看各个进程的状态</li>  <li>supervisorctl reload 重启supervisor 下的所有进程</li>  <li>supervisorctl stop name 停止指定进程</li>  <li>supervisorctl start name 启动指定进程</li>  <li>supervisorctl restart all 重启supervisor 下的所有进程</li></ul><h2 id="FAQ">  <a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul>  <li>    <p>Error: Another program is already listening on a port</p>    <pre><code class="ssh">find / -name supervisor.sockunlink /***/supervisor.sock</code></pre>  </li>  <li>    <p>文件找不到</p>    <p>      <code>unix:///tmp/supervisor.sock no such file</code>    </p>    <p>编辑文件/etc/supervisord.conf 中的</p>    <pre><code>file = /tmp/supervisor.sock ;改成file = /var/run/supervisor.sock</code></pre>  </li></ul><p>​ 然后执行</p><pre><code class="ssh">touch /var/run/supervisor.sockservice supervisord restart</code></pre><ul>  <li>    <p>ERROR (spawn error)</p>    <p>确认脚本文件能够正常使用</p>  </li>  <li>    <p>error while loading shared libraries: libpython2.7.so.1.0</p>    <p>找到libpython2.7.so.10点位置</p>    <pre><code class="ssh">[root@testlm01v ~]# locate libpython2.7.so.1.0/usr/local/Python-2.7.11/libpython2.7.so.1.0/usr/local/lib/libpython2.7.so.1.0</code></pre>    <p>把找到的位置复制到/etc/ld.so.conf.d/python.conf中如</p>    <pre><code>[root@testlm01v /etc/ld.so.conf.d]# cat python.conf /usr/local/lib</code></pre>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>开源工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
