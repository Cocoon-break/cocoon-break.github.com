<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>身份证识别跑批脚本</title>
    <link href="/2018/03/21/%E8%84%9A%E6%9C%AC%E8%B7%91%E6%89%B9/"/>
    <url>/2018/03/21/%E8%84%9A%E6%9C%AC%E8%B7%91%E6%89%B9/</url>
    
    <content type="html"><![CDATA[<p>很久没写了，做下记录吧！</p><ul>  <li>    <p>shell脚本遍历子目录及子目录下的文件，并将文件去发请求，把接口返回回来的json写入到文件中</p>    <pre><code class="shell">#!/bin/bashfunction getdir(){    url = $2    for element in `ls $1`    do          dir_or_file=$1&quot;/&quot;$element        if [ -d $dir_or_file ]        then             getdir $dir_or_file        else            filepath=${dir_or_file%.*}            #不带文件后缀的文件路径            filename=${filepath//\//\_}            #把文件路径中的反斜线换成下划线            if [ -e ${dir_or_file%.*}.jpg ]            then                 curl -F img=@${dir_or_file%.*}.jpg $url &gt; idcard_result/${filename}.json                elif [ -e ${dir_or_file%.*}.png ]               then                curl -F img=@${dir_or_file%.*}.png $url &gt; idcard_result/${filename}.json            fi        fi      done}parentpath=$1mkdir idcard_resulturl=http://10.201.102.163:9002/faceid/v1/idcard#echo $parentpath http://10.201.102.163:9002/faceid/v1/idcardecho $urlgetdir $parentpath $url</code></pre>  </li>  <li>    <p>python 比较身份证正确答案的json文件和ocr识别结果的文件进行核对，统计是否识别正确。python版本为2.7.13。以下为check.py的源码,因为在python2.7里json.load出来的json      是unicode编码的，所以比较的时候在自己的中文中添加U。如：std[U’姓名’]</p>    <a id="more"></a>    <pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-import sysimport jsonreload(sys)sys.setdefaultencoding(&#39;utf-8&#39;)def startcheck(originfile, ocrfile):    with open(originfile, &#39;r&#39;) as f:        std = json.load(f, encoding=&#39;utf-8&#39;)    with open(ocrfile, &#39;r&#39;) as f:        rst = json.load(f, encoding=&#39;utf-8&#39;)    result = True    if rst[&#39;side&#39;] == &#39;front&#39;:        bd = rst[&#39;birthday&#39;]        bd_date = bd[&#39;year&#39;] + &#39;年&#39; + bd[&#39;month&#39;] + &#39;月&#39; + bd[&#39;day&#39;] + &#39;日&#39;        if rst[&#39;name&#39;] != std[U&#39;姓名&#39;]:            result = False        if rst[&#39;gender&#39;] != std[U&#39;性别&#39;]:            result = False        if rst[&#39;race&#39;] != std[U&#39;民族&#39;]:            result = False        if bd_date != std[U&#39;出生&#39;]:            result = False        if rst[&#39;address&#39;] != std[U&#39;住址&#39;]:            result = False        if rst[&#39;id_card_number&#39;] != std[U&#39;公民身份号码&#39;]:            result = False    else:        if rst[&#39;issued_by&#39;] != std[U&#39;签发机关&#39;]:            result = False        if rst[&#39;valid_date&#39;] != std[U&#39;有效期&#39;]:            result = False    strResult = str(result)    content = &#39;%s,%s,%s,\n&#39; % (originfile, ocrfile, strResult)    with open(&#39;./check_result.csv&#39;, &#39;a&#39;) as f:        f.write(content)if __name__ == &#39;__main__&#39;:    originfile_path = sys.argv[1]    print &#39;originfile_path:::&#39;, originfile_path    ocrfile_path = sys.argv[2]    print &#39;ocrfile_path:::&#39;, ocrfile_path    startcheck(originfile_path, ocrfile_path)</code></pre>    <pre><code class="shell">python check.py real.json ocr.json</code></pre>    <p>real.json</p>    <pre><code class="json">{  &quot;住址&quot;: &quot;山东省招远市温泉路309号&quot;,  &quot;姓名&quot;: &quot;杜英男&quot;,  &quot;民族&quot;: &quot;汉&quot;,  &quot;性别&quot;: &quot;女&quot;,  &quot;公民身份号码&quot;: &quot;230122195807160467&quot;,  &quot;出生&quot;: &quot;1988年7月16日&quot;}</code></pre>    <p>ocr.json</p>    <pre><code class="json">{  &quot;address&quot;: &quot;湖南省长沙县安沙镇泗洲村龙口组337号&quot;,  &quot;address_confidence&quot;: [],  &quot;birthday&quot;: {    &quot;day&quot;: &quot;11&quot;,    &quot;day_confidence&quot;: [],    &quot;month&quot;: &quot;2&quot;,    &quot;month_confidence&quot;: [],    &quot;year&quot;: &quot;1994&quot;,    &quot;year_confidence&quot;: []  },  &quot;card_bound&quot;: {},  &quot;gender&quot;: &quot;男&quot;,  &quot;gender_confidence&quot;: [],  &quot;head_rect&quot;: {},  &quot;id_card_number&quot;: &quot;430121198402117321&quot;,  &quot;idnumber_confidence&quot;: [],  &quot;name&quot;: &quot;王威一&quot;,  &quot;name_confidence&quot;: [],  &quot;race&quot;: &quot;汉&quot;,  &quot;race_confidence&quot;: [],  &quot;request_id&quot;: &quot;1521613434,cdc90cd4-ea2e-4bf9-b112-bce711ba2e90&quot;,  &quot;side&quot;: &quot;front&quot;,  &quot;time_used&quot;: 346}</code></pre>    <p>​</p>  </li>  <li>    <p>切分文件进行比对，同时生成md文件，通过typora导出pdf可视化文件</p>    <pre><code class="shell">#!/bin/bashfor f in `ls -v *.jpg | grep _ |cut -d_ -f 1 |uniq -c |awk &#39;{print $2}&#39;`do#echo ${f}_0.jpga=`curl -F image_idcard=@${f}_0.jpg -F image_best=@${f}_1.jpg -F watermark=1 http://10.201.102.104:9000/verify | jq -c -r .confidence`echo ![img](http://localhost:8080/${f}_0.jpg) ![img](http://localhost:8080/${f}_1.jpg) &gt;&gt;$a.md #echo ${f}_0.jpg ${f}_1.jpg $a &gt;&gt; a.logdone</code></pre>    <p>ls -v 排序列出所有文件</p>    <p>grep _ 标记出带有下滑线的</p>    <p>cut -d _ -f 1 将文件按下划线切分取第一部分</p>    <p>uniq -c 显示重复的数量和cut -d _ -f 1的部分</p>    <p>awk ‘{print $2}’ 打印出cut -d _ -f 1部分</p>    <p>​</p>    <p>​</p>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密算法简介</title>
    <link href="/2017/08/28/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2017/08/28/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>​ 对于加密算法我也不是很熟，只能是单纯去使用，但是最近做项目时涉及到国密算法，由于个人对算法差不多是七窍通了六窍，一窍不通啊。于是同事给我科普了一下。</p><p>​ 先将加密算法分两个大方向：1. 不可逆的加密算法 2. 不可逆的加密算法</p><h2 id="不可逆的加密算法">  <a href="#不可逆的加密算法" class="headerlink" title="不可逆的加密算法"></a>不可逆的加密算法</h2><p>​ 不可以逆的意思就是说，加密之后，你也不知道加密前的明文。如果要确认加密前的明文，你只能重新将明文加密一遍，看两次得出来的密文是否一致。不可逆加密算法的特征是加密过程中不需要使用密钥，直接输入明文通过算法处理后得到密文。</p><p>​ 典型的不可逆的加密算法是  <strong>MD5</strong> : MD5对要加密的对象没有大小限制，加密之后的密文长度为  <strong>128bit</strong>,这里是128bit和字节是不一样的，转换成字节的话也就是16Byte。</p><pre><code class="sh">~/tmp » md5 test.jpgMD5 (test.jpg) = f368d709b8652bf78f9ce61d9fd70d7a</code></pre><p>上面的例子通过md5加密了一张图片, MD5加密之后得到值是128bit，按4位二进制组合成一个十六进制，所以得出来的十六进制字符串是32个。</p><p>一般来说不可逆的加密算法得出来的密文是定长的，无论要加密的内容大小是多少，如md5是32，sha256是64，sha512是128</p><a id="more"></a><h2 id="可逆的加密算法">  <a href="#可逆的加密算法" class="headerlink" title="可逆的加密算法"></a>可逆的加密算法</h2><p>​ 可逆的加密算法就是加密之后，还是有办法能够得到明文。可逆的加密算法又可分为对称加密和非对称加密。RSA就是典型的非对称的可逆加密算法。</p><ol>  <li>    <p>对称的可逆加密算法</p>    <p>对称的加密算法，加密和解密用的都是同一个密钥，这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。对称加密算法的特点是算法公开、计算量小、加解密速度快、加解密效率高</p>  </li>  <li>    <p>非对称的可逆加密算法</p>    <p>非对称密钥算法是指一个加密算法的加密密钥和解密密钥是不一样的，或者说不能由其中一个密钥推导出另一个密钥。这两个密钥其中一个称为公钥，用于加密，是公开的，另一个称为私钥，用于解密，是保密的。其中由公钥计算私钥是计算上不可行的。</p>  </li></ol><ul>  <li>分组加密    <ul>      <li>向量加密</li>    </ul>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网端口映射到外网</title>
    <link href="/2017/08/21/%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91/"/>
    <url>/2017/08/21/%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>​ 最近有一个客户想要看我们的产品，想体验一下我们的产品，需要我们提供一个小程序，于是就弄了一个小程序给客户，小程序还好说我们有现成的东西，直接给客户，麻烦的是小程序背后的服务。由于我们背后的人脸识别服务都是私有化部署的，而且这个客户只是想零时体验一下，所以将整个服务部署到公有云完全是没有必要的。但是我们内部有已经部署好的，又不想在公有云上去搭建一套。于是去咨询了下同事，是不是有什么工具可以把内网的端口暴露到公网上。然后同事就介绍了一个工具  <code>autossh</code></p><p>​ 好了背景介绍完了，接下来就是去实践了。</p><p>现有两台服务器：服务器A是阿里云上的一台机器，服务器B是公司内部的一台虚拟机，这个台虚拟机必须是可以连接公网的。</p><a id="more"></a><ol>  <li>    <p>登录到服务B上</p>    <pre><code class="sh">#1.将autossh下载到服务器B上wget http://fossies.org/Linux/privat/autossh-1.4e.tgz#2.解压tar xzvf autossh-1.4e.tgz#3. 编译安装 cd autossh-1.4e ./configure make make install#4. 生成服务器B的公钥，一会儿需要把服务器B的公钥添加到服务器A上ssh-keygen#5. 执行ssh-keygen 一路回车即可，这个会在~/.ssh目录下生成id_rsa.pub,编辑这个文件，把内容复制到一个文本文件vim ~/.ssh/id_rsa.pub</code></pre>  </li></ol><ol>  <li>    <p>登录到服务器A上</p>    <pre><code class="sh">#1.在~/.ssh目录下创建authorized_keys文件touch ~/.ssh/authorized_keys#2.编辑这个文件并将刚才从服务器A上复制的公钥粘贴到这个文件上，保存退出即可vim ~/.ssh/authorized_keys</code></pre>  </li>  <li>    <p>登录到服务器B上</p>    <pre><code class="sh">#1.制定需要暴露到公网端口autossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa 服务器A的用户名@服务器A的IP地址</code></pre>    <p>参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连</p>    <p>后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口</p>  </li></ol><p>到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。是不是很简单</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>私有化的坑</title>
    <link href="/2017/07/20/%E7%A7%81%E6%9C%89%E5%8C%96%E7%9A%84%E5%9D%91/"/>
    <url>/2017/07/20/%E7%A7%81%E6%9C%89%E5%8C%96%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>​ 最近遇到的坑确实是有点多了，这里记录一下。事情开始是这样的，想将公有云的一套工程进行私有化，因为公有云的是自己的系统，不用考虑太多的因素，想统一环境还是比较容易的，只要能够在一套环境成功运行，其他的直接copy就行。但是私有云就不行了，各个客户使用的环境都有一定的差异。私有化就是将使这个工程能够在不同的环境运行。</p><p>​ 公有云的这套工程是python工程，python工程使用了一些so库。而这些so库又依赖系统的  <code>/lib64/libc.so.6</code>，然后工程就报  <code>version &quot;GLIBC_2.14&quot; not found</code>,原因是系统libc不支持GLIBC_2.14这个版本，这时我就有两个解决方案，一个是我将系统的libc.so.6  升级，还有一个我弄一个统一的环境。很显然方案一不是私有云，我总不能让我所有的客户去升级libc.so.6吧，着很显然不符合私有化。</p><p>​ 在尝试方案一的过程中，我发现原来把一个Linux系统弄崩其实很简单，崩了之后各种无法使用，你只能去重装系统。你只要执行  <code>mv /lib64/libc.so.6 /lib64/libc.so.6.bak</code>,你会发现接下来无论你输入什么命令都不好使了。这是因为  <code>/lib64/libc.so.6</code>是最底层的库，系统上的程序基本是依赖这个库的。所以/lib64下的so库不要轻易去动。</p><a id="more"></a><p>​ 于是我去尝试了第二种方案，弄一个统一的环境，那要怎么弄呢？so 库是依赖系统的libc.so.6，我要怎么让我的这个工程的so不去依赖/lib64 下的so而是去依赖我指定的一个路径的so呢？</p><ol>  <li>    <p>我先用docker搭建一个可以运行工程的环境，使用docker弄了一个ubuntu的系统。以下是一些使用的命令</p>    <pre><code class="sh">docker pull ubuntu #获取ubuntu的镜像docker run -it --name kas -v /Users/wushengping/dockerUbuntu:/go -p 9001:9001 ubuntu bash #第一次以交互模式启动ubuntu，并命名为kas，同时将ubuntu系统端口9001映射到本机上docker ps -a #查看docker 下所有container状态docker start kas # 启动kas,kas是ubuntu系统镜像，只是启动并为进入交互模式docker exec -it kas bash #进入ubuntu 交互模式</code></pre>  </li>  <li>    <p>在ubuntu上可以正常运行之后，通过ldd 的命令将so依赖的系统相关的so 导出来,同时将/lib64/ld-linux-x86-64.so.2 也导出来</p>    <pre><code class="sh">  cp `ldd xxxx.so | awk &#39;{print $3}&#39; | grep &#39;^[^(]&#39;` ~/libs  cp /lib64/ld-linux-x86-64.so.2  ~</code></pre>  </li>  <li>    <p>将刚才的导出的库，传到redhats6.4系统上，然后指定工程运行所需的依赖库。</p>    <pre><code class="sh">  ld-linux-x86-64.so.2 --library-path ./libs python xxxx #xxx表示工程的入口文件</code></pre>    <p> 这时你会发现这个工程起都起不来了，并报了core dump 的错误，这时因为指定路径之后，只能通过二进制的方式去启动这个工程。而python 只是一个命令，并不是二进制的文件，无法执行。这里需要注意的是ld-linux-x86-64.so.2      只能是刚才从ubuntu导出来的文件，否则也会报core dump</p>  </li>  <li>    <p>在第三步我们没有成功运行起来，是因为我们还缺少将python工程编译成一个二进制可执行的文件。      <strong>pyInstaller</strong> 这个工具可以将python工程打成一个二进制的包，同时会将工程依赖的库也打进这个二进制。</p>    <pre><code class="sh">  pyinstall -f entry.py #entry.py 是你整个工程的入口文件</code></pre>    <p> 执行完成之后会生成一个dist目录，目录下有整个工程的二进制文件</p>  </li>  <li>    <p>整个私有化的流程算是完成了交付给客户的时候包括一下文件</p>    <ul>      <li>ld-linux-x86-64.so.2</li>      <li>libs </li>      <li>        <p>可执行的二进制文件</p>        <p>当然实际交付的工程中有更多的文件，看工程是怎么规划的。这里不过多解释</p>      </li>    </ul>  </li></ol><p>本篇文章主要是记录私有化工程的一些思路，过程中遇到的很多坑。很多细节这里也不去体现了。大家自行领会。其中关于的docker的使用和pyinstaller 的安装使用，不是本篇文章的重点。可以自行谷歌</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xargs 和 jq</title>
    <link href="/2017/07/05/xargs%E5%92%8Cjq/"/>
    <url>/2017/07/05/xargs%E5%92%8Cjq/</url>
    
    <content type="html"><![CDATA[<p>​ xargs是Linux系统上自带的命令，xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。jq 不是Linux系统自带的命令，需要自行安装。jq主要在Linux上解析json。</p><h2 id="xargs">  <a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>​ 举一个例子，我们常用的一个命令  <code>rm -rf *.log</code> 如果文件log文件太多我们会得到一个异常的信/bin/rm Argument list too long，也就是说rm能接受的参数是有限的。这时我们就可以利用xargs  过滤。</p><pre><code class="sh">ls *.log | xargs rm -rf</code></pre><p>ls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。</p><p>  <strong>题外话：</strong> Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：  <code>rm -rf -xxxx.log</code>是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。可以通过在文件名前加两个减号解决。</p><p>如  <code>rm -rf -- -xxxx.log</code></p><p>​ xargs 的具体用法，还是一个文件夹中有一大堆文件，通过  <code>ls</code>可以将文件多行输出。但是我想单行或者指定行数输出呢！通过给xargs指定-n 参数。</p><pre><code class="sh">ls *.log | xargs -n2 #-n2 就是指定两行输出，-n3就是三行输出，以此类推</code></pre><p>前面都是一些简易的操作，感觉不到xargs 到底是怎么处理管道出来的文件。现在我的一个需求是将所有的log文件复制到指定目录下。普通复制命令  <code>cp xxx.log /var/log</code>。我们先忽略cp 命令有-r参数。先看看以下写法是否正确</p><a id="more"></a><pre><code class="sh">ls *.log | xargs cp /var/log</code></pre><p>你一看立马就觉得不对，cp 不是接受两个参数吗？一个文件，一个目标文件或路径。可是又不知道怎么去解决这个事。在我们上面的例子都真正没有去理解xargs，如  <code>ls *.log | xargs rm -rf</code> 为什么能好使？ls出来的文件通过管道传递给xargs 过滤，然后xargs 过滤出的文件默认追加到命令行的最后。但是在这个例子中，我们不想将xargs吐出来的放到命令行的最后。xargs的占位符就发挥作用了，将上面的命令修改</p><pre><code class="sh">ls *.log | xargs -I {} cp {}  /var/log/</code></pre><p>通过  <code>-I</code>参数指定大括号为占位符，cp后的大括号就是xargs 吐出来的文件名。这里不一定使用大括号，也可指定其他的符号。  <code>-i</code>默认的占位符就是大括号</p><pre><code class="sh">ls *.log | xargs -i cp {} /var/log/</code></pre><p>xargs还有一个-P的参数，是指定xargs同时处理多少个命令。但是感觉没什么效果。例子  <code>ls *.log | xargs -P 8 -i cp {} /var/log/</code></p><p>xargs 的使用就讲到这里</p><h2 id="jq">  <a href="#jq" class="headerlink" title="jq"></a>jq</h2><p>jq 命令并不是Linux系统自带的，所以我们需要格外安装。  <a href="https://stedolan.github.io/jq/download/" target="_blank" rel="noopener">下载的地址</a></p><p>jq 的官方说法是jq is like  <code>sed</code> for JSON data - you can use it to slice and filter and map and transform  structured data with the same ease that  <code>sed</code>,  <code>awk</code>,  <code>grep</code> and friends let you play with text。使用jq在Linux系统上去处理json是非常方便的。比如在终端上curl一个接口，返回一个json，这个json可能很长，我只想看其中部分数据，就可以用上jq了。</p><p>jq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。哈哈哈</p><p>  <a href="https://stedolan.github.io/jq/tutorial/" target="_blank" rel="noopener"> 官方教程</a></p><h2 id="自己实践的例子">  <a href="#自己实践的例子" class="headerlink" title="自己实践的例子"></a>自己实践的例子</h2><p>前段时间有需要将两万张的照片去发起请求，然后处理curl返回的结果。利用了xargs和jq。将命令贴出来记录一下。</p><pre><code class="sh">ls TP | xargs -i -n1 curl -s -F img=@TP/{} http://127.0.0.1:9001/faceid/v1/liveness_cfg                                                                 | jq -c -r &#39;[.liveness.mask,.liveness.replay,.liveness.graphics]&#39; &gt; TP.txt &amp;</code></pre><p>TP就是有两万张照片的文件夹，将请求的结果通过jq处理，然后输出到TP.txt文件 中</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>caddy的简易使用</title>
    <link href="/2017/06/30/caddy%E7%9A%84%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2017/06/30/caddy%E7%9A%84%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>​ caddy是一个开源的，使用golang 编写，支持HTTPS的web服务器，同时也可以作为负载均衡器使用，caddy的使用非常简单，只要一个二进制包就可以执行，不用像apache  或者nginx 配置起来那么麻烦。</p><p>​  <a href="https://caddyserver.com/download" target="_blank" rel="noopener">caddy下载</a></p><p>​ caddy可以使用命令行参数的方式去执行，也可以指定配置文件去执行。使用命令行去执行，具体的参数名称参考  <a href="https://caddyserver.com/docs/cli" target="_blank" rel="noopener">caddy 接收参数</a></p><p>​ caddy在某个文件夹下直接执行，通过访问  <a href="http://localhost:2015访问文件下的所有内容。使用起来非常简单。" target="_blank" rel="noopener">http://localhost:2015访问文件下的所有内容。使用起来非常简单。</a></p><h3 id="使用">  <a href="#使用" class="headerlink" title="使用"></a>使用</h3><p> 通过配置文件来使用caddy，执行是  <code>caddy -conf caddyfile</code>, 给caddy 配置不同的caddyfile如下</p><ul>  <li>    <p>使用caddy 负载均衡，配置caddyfile</p>    <pre><code class="sh">:1234proxy / ip1:port1,ip2:port2,ip3:port3{  policy random  health_check /version  health_check_interval 30s  health_check_timeout 30s}log ／ /var/log/caddy.log {    rotate_size    100    rotate_age      7    rotate_keep     5}</code></pre>    <p>注：caddy监听本机      <code>1234</code>端口，分别将请求转发给      <code>ip1:port1,ip2:port2,ip3:port3</code> 三台机器，policy为负载均衡的策略，random表示从三台机器上随机选择负载，也有其他选项least_conn,      round_robin, first, ip_hash, or uri_hash。      <code>health_check</code>是对三台机器提供的服务进行健康检查，/version 为进行健康检查的接口。每30秒进行一次健康检查，每次检查超过30秒表示失败。如果发现这个接口不能正常返回，则回被caddy标识为不健康的服务，则后续的负载不会到不健康的服务上。配置log记录caddy日志信息</p>  </li></ul><a id="more"></a><ul>  <li>    <p>使用caddy作为静态资源服务器，配置caddyfile</p>    <pre><code class="sh">:1234root /opt/testbrowseext .pdf .html .htm</code></pre>    <p> 注：caddy监听本机的      <code>1234</code>端口，指定了访问的根目录为/opt/test,如果/opt/test 目录下没有index.html,那么访问      <code>http://ip:1234</code> 会将/opt/test目录结构展现到页面中。ext 表示可以忽略文件的后缀</p>    <p>​</p>  </li></ul><p>更多的配置可以访问  <a href="https://caddyserver.com/docs/http-caddyfile" target="_blank" rel="noopener">caddy配置文件</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公众号开发前端</title>
    <link href="/2017/06/19/%E5%85%AC%E4%BC%97%E5%8F%B7web%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2017/06/19/%E5%85%AC%E4%BC%97%E5%8F%B7web%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>上一篇讲了微信公众号后端的开发，这一篇是讲讲前端页面的开发。前端的技术栈用的是react。这里介绍了在开发过程中遇到的一些问题。以及一些知识点的介绍</p><p>以下步骤的前提是你已经安装了node，才能继续往下走。</p><h2 id="创建一个node工程">  <a href="#创建一个node工程" class="headerlink" title="创建一个node工程"></a>创建一个node工程</h2><p>​ 初始化一个工程，并进行一些基本信息填写。执行  <code>npm init</code>，根据提示填写信息，最后会生成一个package.json 文件。这样一个node工程初始化完成了。以下package.json  文件是我修改过的，默认生成的文件和这个是有差异的。主要讲解几个字段，main:表示入口文件，scripts：主要是脚本命令，执行npm start 的时候，它会执行scripts  下start 后的命令，dependencies：是工程依赖的一些库，devDependencies：主要是开发的时候使用的一些库，生产的时候不需要使用。</p><a id="more"></a><pre><code class="json">{  &quot;name&quot;: &quot;doudou-client&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;wechat public&quot;,  &quot;main&quot;: &quot;app.js&quot;,  &quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;,    &quot;dev&quot;: &quot;webpack -d --watch&quot;  },  &quot;author&quot;: &quot;cocoon&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: {  },  &quot;devDependencies&quot;: {    &quot;webpack&quot;: &quot;^1.12.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^1.12.1&quot;  }}</code></pre><p>​ 有一个package.json 文件还不能使用，接下来是编写app.js文件，也就是入口文件，我们就简易的写一个demo文件吧！我们要使用react进行开发我们就得安装reactjs  相关的依赖，执行以下命令来添加reactjs 依赖的库,和开发时使用的一些开发库。如：webpack</p><pre><code class="sh">npm install --save react react-domnpm install --save-dev css-loadernpm install --save-dev style-loadernpm install --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-reactnpm install --save-dev webpack webpack-dev-server</code></pre><p>创建一个app.js文件</p><pre><code class="jsx">import React, { Component } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;class App extends Component {    render() {           return (               &lt;div&gt;hello wechat test&lt;/div&gt;           );       }}ReactDOM.render((       &lt;App/&gt;), document.getElementById(&#39;container&#39;));</code></pre><p>​ 除了js文件之外，我们还需要一个 html文件，来加载这些js文件。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css&quot; /&gt;    &lt;title&gt;微信公众号网页&lt;/title&gt;    &lt;script&gt;        function setHeight() {            console.log(screen.height)            document.body.style.height = screen.height + &#39;px&#39;;        }    &lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;width: 100%;&quot; onload=&quot;setHeight()&quot;&gt;&lt;div id=&quot;container&quot; id=&quot;container&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./assets/vendor.bundle.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./assets/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>​ 发现我们的html页面中并没有加载app.js文件，是因为我们通过webpack 来打包js文件，css文件，图片等。html页面加载的是我们打包之后的文件。所以我们在工程目录下创建一个webpack.config.js文件，来配置webpack一些打包的配置项</p><pre><code class="js">var webpack = require(&#39;webpack&#39;);var path = require(&#39;path&#39;);var autoprefixer = require(&#39;autoprefixer&#39;);var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);var OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;);module.exports = {    entry: {        js: [&#39;./app.js&#39;],        vendor: [&#39;react&#39;, &#39;classnames&#39;, &#39;react-router&#39;, &#39;react-dom&#39;, &#39;react-addons-css-transition-group&#39;]    },    output: {        path: path.resolve(__dirname, &#39;dist&#39;),        filename: &#39;./bundle.js&#39;    },    devServer:{        proxy:{            &#39;/api&#39;:{                target:&#39;http://localhost:5000&#39;,                secure: false,                changeOrigin: true,                pathRewrite: {&#39;^/api&#39;: &#39;&#39;}            }        },    },    module: {        loaders: [            {                test: /\.js[x]?$/,                exclude: /node_modules/,                loader: &#39;babel&#39;,                query: {                    cacheDirectory: true,                    presets: [&#39;es2015&#39;, &#39;react&#39;]                }            }, {                test: /\.less$/,                loader: &#39;style!css!postcss!less&#39;            }, {                test: /\.css/,                loader: ExtractTextPlugin.extract(&#39;style&#39;, &#39;css&#39;, &#39;postcss&#39;)            }, {                test: /\.(png|jpg|svg)$/,                loader: &#39;url?limit=25000&#39;            }        ]    },    postcss: [autoprefixer],    plugins: [        new webpack.DefinePlugin({            DEBUG: process.env.NODE_ENV !== &#39;production&#39;        }),        new ExtractTextPlugin(&#39;weui.min.css&#39;),        new webpack.optimize.CommonsChunkPlugin(&#39;vendor&#39;, &#39;vendor.bundle.js&#39;),        new HtmlWebpackPlugin({            template: path.join(__dirname, &#39;./index.html&#39;)        }),    ]};</code></pre><p>​ 更多的webpack学习，请移步  <a href="https://zhaoda.gitbooks.io/webpack/content/" target="_blank" rel="noopener">webpack学习入门</a></p><p>整个工程demo在GitHub上  <a href="https://github.com/Cocoon-break/wechat_public_template" target="_blank" rel="noopener">wechat_public_template</a></p><h2 id="常规问题">  <a href="#常规问题" class="headerlink" title="常规问题"></a>常规问题</h2><ul>  <li>    <p>网页无法适应全屏？</p>    <p>在开发过程中发现body标签高度始终无法全屏，及时设置高度为100%，也无法生效。</p>    <pre><code class="html">&lt;!--1.添加移动适配设置 --&gt;&lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;&lt;!--2.添加js动态的把body高度设置为，设备屏高--&gt;&lt;script&gt;        function setHeight() {            document.body.style.height = screen.height + &#39;px&#39;;        }&lt;/script&gt;&lt;!--3.在body onload 时执行js--&gt;&lt;body style=&quot;width: 100%;&quot; onload=&quot;setHeight()&quot;&gt;&lt;/body&gt;</code></pre>    <p>​</p>  </li></ul><h2 id="开源库使用时遇到的问题">  <a href="#开源库使用时遇到的问题" class="headerlink" title="开源库使用时遇到的问题"></a>开源库使用时遇到的问题</h2><ul>  <li>    <p>在使用react-weui 发现样式无法生效</p>    <pre><code class="js">import &#39;react-weui/lib/react-weui.min.css&#39;;//导入对应样式文件</code></pre>  </li>  <li>    <p>在使用fontawesome 时，发现图标无法显示</p>    <pre><code class="html"> &lt;!--在html中把样式文件加上--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;&gt;</code></pre>  </li>  <li>    <p>开发时想通过fetch直接请求服务端接口，解决跨域问题</p>    <pre><code class="js">//package.json 使用webpack-dev-server 启动开发环境，重点是-d&quot;scripts&quot;:{  &quot;start&quot;: &quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;,}//webpack.config.js 配置代理  module.exports = {    //其他配置省略    devServer:{        proxy:{            &#39;/api&#39;:{                target:&#39;http://localhost:5000&#39;,                secure: false,                changeOrigin: true,                pathRewrite: {&#39;^/api&#39;: &#39;&#39;}            }        },    },  }//使用时代码  fetch(&#39;/api/show_operation/1&#39;)            .then(response=&gt;response.json())            .then(result=&gt;console.log(result))//说明：通过proxy配置可以最终发出的请求路径为http://localhost:500/show_operation/1</code></pre>    <p>​</p>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 开发服务端</title>
    <link href="/2017/06/19/python%20%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <url>/2017/06/19/python%20%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>最新在开发微信公众号，选择了python做为后端开发的语言。之所以选择python作为开发语言，是因为python开发起来比较快，而且也容易上手。选用的python版本是python2.7.13</p><h2 id="先了解下python的一些基本知识">  <a href="#先了解下python的一些基本知识" class="headerlink" title="先了解下python的一些基本知识"></a>先了解下python的一些基本知识</h2><ul>  <li>    <p>在mac 上执行      <code>pip install xxx</code>会把包安装到哪里？</p>    <p>如果Mac上装了多个版本的Python，可以同过      <code>python --version</code>查看，然后会将包安装到      <code>/usr/local/lib/pythonxxx/site-packages</code>下</p>  </li>  <li>    <p>创建虚拟开发环境</p>    <p>在使用Python开发的时候，各个应用所需的Python版本可能不同，这时我们就需要一个独立的Python开发环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>    <ul>      <li>        <p>安装virtualenv</p>        <pre><code class="sh">pip install virtualenv</code></pre>      </li>      <li>        <p>创建一个目录并创建一个独立的Python环境venv</p>        <pre><code class="sh">mkdir testPythoncd testPythonvirtualenv --no-site-packages venv</code></pre>        <p>          <strong>注：</strong> 参数          <code>--no-site-packages</code>，不会将系统已安装的第三方包复制过来，这样我们就得到一个干净的Python开发环境</p>      </li>      <li>        <p>使用这个venv环境</p>        <pre><code class="sh">source venv/bin/activate</code></pre>        <p>接下来          <code>pip install xxx</code> 都会把Python包放在          <code>testPython/venv/lib/python2.7/site-packages</code>目录下</p>      </li>      <li>        <p>离开venv 环境</p>        <pre><code class="sh"> deactivte</code></pre>      </li>    </ul>    <p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令      <code>source venv/bin/activate</code>进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令      <code>python</code>和      <code>pip</code>均指向当前的virtualenv环境。</p>  </li></ul><p>​  <strong>注：</strong> 使用venv 环境之后，执行  <code>pip install xxxx</code> ，它会把这些依赖包安装在  <code>venv/lib/python2.7/site-packages</code>目录下</p><ul>  <li>    <p>依赖第三方库的统一配置文件      <strong>requirements.txt</strong>    </p>    <pre><code class="text">Flask==0.12</code></pre>    <p>通过      <code>pip install -r requirements.txt</code>来安装文件中依赖的一些第三方库</p>  </li></ul><a id="more"></a><h2 id="项目开发">  <a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>flask是python的一个轻量级Web应用框架，对于一些小的站点来说flask，已经能够满足需求了。执行  <code>pip install flask</code>安装。  <a href="http://flask.pocoo.org/" target="_blank" rel="noopener">flask 官网</a></p><p>创建一个run.py文件，写如以下代码。然后执行python run.py，一个简易的web服务就OK了。访问localhost:8080端口</p><pre><code class="python">from flask import Flask, requestapp = Flask(__name__)@app.route(&#39;/test&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def test():    return jsonify({&#39;msg&#39;:&#39;hello world&#39;})if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, port=8080)</code></pre><p>链接数据库使用的sqlalchemy, sqlalchemy 是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。  <a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy官网</a></p><ul>  <li>    <p>本地机器已经安装了mysql，但是在使用sqlalchemy 报No module named mysql。</p>    <pre><code class="python"> pip install pymysql</code></pre>  </li>  <li>    <p>链接数据库样例</p>    <pre><code class="python"> from sqlalchemy import Column, String, create_engine # 初始化数据库连接: engine = create_engine(&#39;mysql+pymysql://&#39;+username+&#39;:&#39;+password+&#39;@localhost:3306/doudouSpace&#39;) def create_user_table():     connect = engine.connect()     try:         result = connect.execute(&#39;xxxx&#39;) #xxx 表示sql语句         result.close()     except Exception as e:         print e</code></pre>    <p>      <strong>注：</strong>更多详细文档请参考官网</p>  </li></ul><p>日志模块也是开发工作中的一个重要部分，可以方便我们调试开发。我们使用python自带的logging模块，我们要将日志信息输出到文件中，而不是只输出到控制台中。</p><ul>  <li>    <p>封装下日志模块</p>    <p>```python      <br>import logging      <br>from logging.handlers import RotatingFileHandler      <br>from . import config</p>    <p>log_filename = ‘output.log’      <br>logging.basicConfig(level=logging.DEBUG,</p>    <pre><code>                format=&#39;%(filename)s:%(lineno)s - %(asctime)s %(levelname)s %(message)s&#39;,                filename=log_filename,                filemode=&#39;a&#39;)</code></pre>    <p>logger = logging.getLogger()      <br>log_handler = logging.handlers.WatchedFileHandler(log_filename)      <br>logger.addHandler(log_handler)</p>  </li></ul><p> def debug(msg):</p><pre><code>  # logging.debug(msg)  logger.debug(msg)</code></pre><p> def info(msg):</p><pre><code>  # logging.info(msg)  logger.info(msg)</code></pre><p> def warning(msg):</p><pre><code>  # logging.warning(msg)  logger.warning(msg)</code></pre><p> def error(msg):</p><pre><code>  # logging.error(msg)  logger.error(msg)</code></pre><p> ```</p><p> ​</p><p>其他的一些在这里就不在过多的介绍了，我做了一个python开发后端rest接口的模版工程，放在GitHub上，有兴趣的话可以看看  <a href="https://github.com/Cocoon-break/python_tmplate" target="_blank" rel="noopener">python_tmplate</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RN 中使用mobx来进行状态管理</title>
    <link href="/2017/06/13/RN%E4%B8%AD%E4%BD%BF%E7%94%A8mobx%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2017/06/13/RN%E4%B8%AD%E4%BD%BF%E7%94%A8mobx%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在使用RN开发app过程中需要状态管理，也就是state 这个概念，由此衍生出来的两个状态管理的框架，一个是redux，另一个就是mobx了。这两个我都用过，今天就先来介绍下mobx  在开发RN中的使用。实际上不使用状态管理的框架，你也是能够进行开发的，但是随着项目的开发以及项目的壮大，会发现没有状态管理，这个工程越来越难维护。当然redux和mobx也都是可以使用在react的web项目中。</p><p>mobx核心的理念是  <strong>动作</strong>改变  <strong>状态</strong>，而状态的改变会更新所有受影响的  <strong>视图</strong>，通俗来讲，一个应用可以拥有一个大的state，而每一个页面都和这个这个state相关连，通过改变这个state来更新页面。当然一个应用可以拥有多个state不一定是一个，这个开每个开发者对项目的规划。举个例子：用户的state,在用户未登录时，页面的显示时登录界面，当用户点击登录时，通过更新这个state，来更新这个view。更多的mobx概念请移步  <a href="http://cn.mobx.js.org/" target="_blank" rel="noopener">mobx中文文档</a></p><p>接下来就是在实际开发中使用mobx了</p><a id="more"></a><ul>  <li>    <p>在package.json 引入</p>    <pre><code class="js">&quot;dependencies&quot;: {    &quot;mobx&quot;: &quot;^2.6.1&quot;,    &quot;mobx-react&quot;: &quot;^3.5.8&quot;,    //其他库}//不加这个装饰器使用不了，如@action   &quot;devDependencies&quot;: {  &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.4&quot;}</code></pre>  </li>  <li>    <p>.babelrc 中添加</p>    <pre><code class="js">{  &quot;presets&quot;: [&quot;react-native&quot;],  &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;] //在babel转义的时候能够将装饰器转义}</code></pre>  </li></ul><h3 id="创建一个简易的计数器">  <a href="#创建一个简易的计数器" class="headerlink" title="创建一个简易的计数器"></a>创建一个简易的计数器</h3><ul>  <li>    <p>创建一个一个store</p>    <pre><code class="js">import {observable, action, computed, toJS} from &#39;mobx&#39;class mobxStore {    @observable count = 0    @action addCount() {        this.count = this.count + 1;    }    @action reduceCount() {        this.count = this.count - 1;    }}const store = new mobxStore()export default store</code></pre>  </li>  <li>    <p>在界面中和store 关联</p>    <pre><code class="javascript">import React, {Component} from &#39;react&#39;;import {    Text,    StyleSheet,    TouchableHighlight,    View} from &#39;react-native&#39;;import {observer} from &#39;mobx-react/custom&#39;import store from &#39;./mobxStore&#39;@observerclass Root extends Component {    render() {        return (            &lt;View style={styles.container}&gt;                &lt;Text style={styles.welcome}&gt;                    Mobx 的简易使用demo                &lt;/Text&gt;                &lt;Text style={styles.instructions}&gt;                    store中的计数器：{store.count}                &lt;/Text&gt;                &lt;TouchableHighlight style={{marginTop: 8}} onPress={() =&gt; store.addCount()}&gt;                    &lt;Text style={styles.instructions}&gt;                        点击计数+1                    &lt;/Text&gt;                &lt;/TouchableHighlight&gt;                &lt;TouchableHighlight style={{marginTop: 8}} onPress={() =&gt; store.reduceCount()}&gt;                    &lt;Text style={styles.instructions}&gt;                        点击计数-1                    &lt;/Text&gt;                &lt;/TouchableHighlight&gt;            &lt;/View&gt;        );    }}const styles = StyleSheet.create({    container: {        flex: 1,        justifyContent: &#39;center&#39;,        alignItems: &#39;center&#39;,        backgroundColor: &#39;#F5FCFF&#39;,    },    welcome: {        fontSize: 20,        textAlign: &#39;center&#39;,        margin: 10,    },    instructions: {        textAlign: &#39;center&#39;,        color: &#39;red&#39;,        marginBottom: 5,    },});export default Root</code></pre>  </li></ul><p>导入  <code>import {observer} from &#39;mobx-react/custom&#39;</code> 和刚才创建的store，  <code>import store from &#39;./mobxStore&#39;</code></p><p>demo 的源码已经放到github上  <a href="https://github.com/Cocoon-break/mobxDemo" target="_blank" rel="noopener">mobxDemo</a>，如有疑问请在该仓库中提issue</p>]]></content>
    
    
    
    <tags>
      
      <tag>react-native</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各个平台上传图片</title>
    <link href="/2017/06/13/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2017/06/13/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>开发时常遇到的一些上传图片操作，这里记录一下。包括android，iOS，和java后端，后面还遇到的其他语言或平台时，会进行补充</p><p>android AsyncHttpClient 上传图片,要使用  <a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">android-async-http</a></p><pre><code class="java">public void uploadImg(String filePath) {        AsyncHttpClient asyncHttpclient = new AsyncHttpClient();        RequestParams params = new RequestParams();        try {            params.put(&quot;liveness&quot;, &quot;1&quot;);            params.put(&quot;img&quot;, new File(filePath));// 传入照片路径        } catch (FileNotFoundException e) {            e.printStackTrace();        }        String url = &quot;&quot;;        asyncHttpclient.post(url, params, new AsyncHttpResponseHandler() {            @Override            public void onSuccess(int statusCode, Header[] headers,                                  byte[] responseByte) {                String successStr = new String(responseByte);                try {                    JSONObject jObject = new JSONObject(successStr)                            .getJSONArray(&quot;faces&quot;).getJSONObject(0);                  //其他省略                } catch (JSONException e) {                    e.printStackTrace();                }            }            @Override            public void onFailure(int statusCode, Header[] headers,                                  byte[] responseBody, Throwable error) {                // 上传失败            }        });    }</code></pre><a id="more"></a><p>iOS NSMutableURLRequest上传图片，NSMutableURLRequest是oc自带库</p><pre><code class="objective-c">- (void) uploadImage:(NSData *)imageData{    //字典里面装的是你要上传的内容    NSDictionary *parameters = @{@&quot;liveness&quot;: @&quot;1&quot;};    //上传的接口    NSString* urlstring = @&quot;http://132.121.1.213:9000/faceid/v1/extract&quot;;    //分界线的标识符    NSString *TWITTERFON_FORM_BOUNDARY = @&quot;AaB03x&quot;;    //根据url初始化request    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]                                                            cachePolicy:NSURLRequestReloadIgnoringLocalCacheData                                                        timeoutInterval:10];    //分界线 --AaB03x    NSString *MPboundary=[[NSString alloc]initWithFormat:@&quot;--%@&quot;,TWITTERFON_FORM_BOUNDARY];    //结束符 AaB03x--    NSString *endMPboundary=[[NSString alloc]initWithFormat:@&quot;%@--&quot;,MPboundary];    //    //要上传的图片    //    UIImage *image=[params objectForKey:@&quot;pic&quot;];    //得到图片的data    //    NSData *data = UIImagePNGRepresentation(self.image);    //http body的字符串    NSMutableString *body=[[NSMutableString alloc]init];    //参数的集合的所有key的集合    NSArray *keys= [parameters allKeys];    //遍历keys    for(int i=0;i&lt;[keys count];i++)    {        //得到当前key        NSString *key=[keys objectAtIndex:i];        //如果key不是img，说明value是字符类型，比如name：Boris        if(![key isEqualToString:@&quot;img&quot;])        {            //添加分界线，换行            [body appendFormat:@&quot;%@\r\n&quot;,MPboundary];            //添加字段名称，换2行            [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;,key];            //添加字段的值            [body appendFormat:@&quot;%@\r\n&quot;,[parameters objectForKey:key]];        }    }    ////添加分界线，换行    [body appendFormat:@&quot;%@\r\n&quot;,MPboundary];    //声明img字段，文件名为boris.png    [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;img\&quot;; filename=\&quot;boris.png\&quot;\r\n&quot;];    //声明上传文件的格式    [body appendFormat:@&quot;Content-Type: image/png\r\n\r\n&quot;];    //声明结束符：--AaB03x--    NSString *end=[[NSString alloc]initWithFormat:@&quot;\r\n%@&quot;,endMPboundary];    //声明myRequestData，用来放入http body    NSMutableData *myRequestData=[NSMutableData data];    //将body字符串转化为UTF8格式的二进制    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];    //将image的data加入    [myRequestData appendData:imageData];    //加入结束符--AaB03x--    [myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];    //设置HTTPHeader中Content-Type的值    NSString *content=[[NSString alloc]initWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,TWITTERFON_FORM_BOUNDARY];    //设置HTTPHeader    [request setValue:content forHTTPHeaderField:@&quot;Content-Type&quot;];    //设置Content-Length    [request setValue:[NSString stringWithFormat:@&quot;%d&quot;, (int)[myRequestData length]] forHTTPHeaderField:@&quot;Content-Length&quot;];    //设置http body    [request setHTTPBody:myRequestData];    //http method    [request setHTTPMethod:@&quot;POST&quot;];    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) {        if(data.length &gt; 0)        {        }    }];}</code></pre><p>java中使用httpClient 上传文件</p><p>pom.xml 中添加 httpclient</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;  &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;  &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code class="java"> public static String postWithFormData(String url, Map map) {        HttpClient client = new HttpClient();        PostMethod postMethod = new PostMethod(url);        try {             String imgPath = (String) map.get(&quot;img&quot;);            FilePart imgpart = null;            if (imgPath != null &amp;&amp; !imgPath.equals(&quot;&quot;)) {               imgpart = new FilePart(&quot;img&quot;, new File(imgPath));            }            StringPart stringPart = new StringPart(&quot;liveness&quot;, &quot;1&quot;);            Part[] parts = {imgpart, stringPart};            MultipartRequestEntity multipartRequestEntity = new MultipartRequestEntity(parts, new HttpMethodParams());            postMethod.setRequestEntity(multipartRequestEntity);            int statusCode = client.executeMethod(postMethod);            if (statusCode != 200) {                Map map1 = new HashMap();                map1.put(&quot;msg&quot;, &quot;http 请求错误&quot;);                return new JSONObject(map1).toString();            }            InputStream inputStream = postMethod.getResponseBodyAsStream();            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));            String line = &quot;&quot;;            StringBuilder sb = new StringBuilder();            while ((line = reader.readLine()) != null) {                sb.append(line + &quot;\n&quot;);            }            inputStream.close();            return sb.toString();        } catch (IOException e) {            e.printStackTrace();            return &quot;&quot;;        }    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>开发随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm,tmux,vim 的常用快捷键</title>
    <link href="/2017/06/02/iterm,tmux,vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2017/06/02/iterm,tmux,vim%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>上一篇博客我们搭建了Mac下流畅的终端使用环境，这篇博客我们讲一些常用的快捷键来提高开发效率。废话不多说我们开始吧</p><h2 id="iterm2-快捷">  <a href="#iterm2-快捷" class="headerlink" title="iterm2 快捷"></a>iterm2 快捷</h2><p>通常我们在使用时，一个窗口总是感觉不够用，这时我们就需要多窗口，或者一个窗口需要多个屏。打开Iterm2，我们按下  <code>command + t</code>，来新建窗口，通过  <code>commmand + w</code>来关闭当前窗口，如果我们想要切换不同的窗口时，我们可以通过  <code>command + 方向键</code> 或者  <code>command + 数字</code>来切换窗口。  <code>command + q</code> 退出应用程序</p><p>  <strong>注：</strong>  <code>command + t</code>或者  <code>command + w</code>或者  <code>command +q</code> 在很多应用都是通用的,比如在chrom 上，这几个快捷键，分别表示新建tab页，关闭tab页，推出chrom。但是chrom  切换tab是使用  <code>command + option +方向键</code> 这个就和iterm2有区别了。</p><p>在链接远程服务器时，我需要在同一窗口，查看不同服务器的状态，或者其他的一些信息。多窗口去查看就太麻烦 了。iterm 的分屏就能满足你的需要了。iterm2在分屏时，可以进行横向分屏和纵向分屏。纵向分屏使用  <code>command + d</code>横向分屏使用  <code>command + shift +d</code>，关闭当前分屏的快捷键也是使用  <code>command + w</code>，切换各个分屏使用的是  <code>command + option + 方向键</code>，以下是效果图</p><a id="more"></a><p>  <img src="https://cocoon-break.github.io/images/screenShot/iterm2_keymap.jpg" srcset="/img/loading.gif" alt></p><p>接下来就是在输入的时候，我们需要快速回到行首使用  <code>ctrl + a</code>，快速回到行末使用  <code>ctrl + e</code>，输入失误就需要删除错误了，  <code>ctrl + u</code>是将当前行清空，使用  <code>ctrl + w</code>,删除光标之前的单词，使用  <code>ctrl + h</code>删除光标之前所有字符，使用  <code>ctrl + k</code> 删除光标之后的所有字符。</p><p>总结下 ：</p><ul>  <li>窗口和屏相关    <ul>      <li>新建窗口：command + t</li>      <li>关闭窗口或者分屏：command + w</li>      <li>切换标签：command + 左右方向键</li>      <li>切换全屏：command + enter</li>      <li>水平分屏：command + shift + d </li>      <li>垂直分屏：command + d </li>      <li>切换分屏：command + option + 方向键</li>    </ul>  </li>  <li>编辑相关    <ul>      <li>清除当前行：ctrl + u</li>      <li>删除光标之前的字符：ctrl + h</li>      <li>删除光标之前的单词：ctrl + w</li>      <li>删除光标到文本末尾：ctrl + k</li>      <li>到行首： ctrl + a</li>      <li>到行末：ctrl + e</li>    </ul>  </li></ul><h2 id="tmux-快捷键">  <a href="#tmux-快捷键" class="headerlink" title="tmux 快捷键"></a>tmux 快捷键</h2><p> 打开iterm2 输入  <code>tmux</code> 就进入了tmux的交互模式了，tmux 也有窗口和屏的概念这里就不再说明了。直接进入主题，快捷键的使用。</p><p>在使用任何功能时我们都得先按下  <code>ctrl + b</code> 然后  <strong>松开</strong>，接着按下其他的键，比如我要新建一个窗口，先按下  <code>ctrl + b</code> 然后在按下  <code>c</code>, 这就完成了窗口的新建。</p><ul>  <li>快捷键都是先按下    <code>ctrl + b</code>然后在按一下键    <ul>      <li>c 新建窗口</li>      <li>&amp; 关闭当前窗口</li>      <li>p 切换至上一个窗口</li>      <li>n 切换至下一个窗口</li>      <li>% 将当前窗口纵向分屏</li>      <li>“ 将当前窗口横向分屏</li>      <li>方向键 在多个分屏中切换</li>      <li>d 脱离当前tmux，在输入tmux attach 就能重新进入</li>      <li>z 使当前屏占满全屏，在次按下则恢复之前屏样式</li>      <li>x 关闭当前屏</li>      <li>alt + 方向键 调整当前屏大小</li>    </ul>  </li></ul><p>这里只将一些基础的快捷键，更多快捷键和配置，请自行谷歌，百度，以下为tmux 分屏之后的效果图</p><p>  <img src="https://cocoon-break.github.io/images/screenShot/iterm2_tmux_keymap.jpg" alt></p><h2 id="vim-快捷键">  <a href="#vim-快捷键" class="headerlink" title="vim 快捷键"></a>vim 快捷键</h2><p>vim 的功能很强大，这里也不会深入讲解介绍，只是收集了一些快捷键，以便提供一些效率。</p><ul>  <li>查找    <ul>      <li>从光标处向下搜索：/ + 要查找的词</li>      <li>从光标处向上搜索：? + 要查找的词</li>      <li>快速回到页首：{</li>      <li>去页尾：}</li>      <li>回行首：shift + ^</li>      <li>回行末：shift + $</li>    </ul>  </li>  <li>编辑    <ul>      <li>删除光标出的字母：x</li>      <li>删除光标所在行：dd</li>      <li>删除单词包括空格：dw</li>      <li>回撤上一次编辑：u </li>      <li>取消撤回功能(对u功取消)：control + r</li>      <li>复制光标所在行：yy</li>      <li>复制n(数字)行：nyy</li>      <li>复制单词：yw</li>      <li>复制n个单词：nyw</li>      <li>复制光标所在位置到行末：y$</li>      <li>复制光标所在位置到行首：y^</li>      <li>粘贴：p</li>    </ul>  </li></ul><p>更多vim 操作快捷键：  <a href="http://www.lcode.cc/2017/04/10/vim-shortcut-key.html" target="_blank" rel="noopener">vim快捷键</a></p><p>这篇博客只是收集和介绍一些基础简单的快捷键，并没有很深入的去使用iterm2 ，tmux，vim，这些功能都很强大，想继续深入的同学可以去查查资料。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下打造流畅的终端使用环境</title>
    <link href="/2017/05/27/Mac%E4%B8%8B%E6%89%93%E9%80%A0%E6%B5%81%E7%95%85%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83/"/>
    <url>/2017/05/27/Mac%E4%B8%8B%E6%89%93%E9%80%A0%E6%B5%81%E7%95%85%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>作为程序员Mac上自带的终端是远远满足不了我们的，这时我们就要自己手动搭一个我们顺手的终端环境。下面我们就来搭建iterm2+ oh my zsh + tmux  的终端工具</p><h2 id="ITerm2-安装">  <a href="#ITerm2-安装" class="headerlink" title="ITerm2 安装"></a>ITerm2 安装</h2><ol>  <li>    <p>上Iterm2的官网下载iterm2,      <a href="http://www.iterm2.com/" target="_blank" rel="noopener">iterm2下载</a>    </p>  </li>  <li>    <p>下载完成之后，发现iterm2 自带的配色我不太喜欢，安装完成之后进行item2的配色，这个纯属看个人喜好了。</p>    <ul>      <li>        <p>要进行配色，我们当然得要有配色的方案啦！什么你要自己配一个，嗯…… 这也是可以的，不过有很多现成的方案你要不要啊。github 上有超多的配色方案，我们先把这个库给clone下来。</p>        <pre><code class="sh">git clone git@github.com:mbadolato/iTerm2-Color-Schemes.git</code></pre>        <p>要是你没有git，那我觉得你没太必要继续下去了。当然你还想继续的话，你就上GitHub手动download 下来。</p>        <a id="more"></a>      </li>      <li>        <p>好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git          克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案，这就看个人喜好了哈，这样你的iterm2配色方案就完成了</p>        <p>          <img src="https://cocoon-break.github.io/images/screenShot/iterm2_color.jpg" alt>        </p>      </li>    </ul>  </li></ol><h2 id="Mac下shell介绍">  <a href="#Mac下shell介绍" class="headerlink" title="Mac下shell介绍"></a>Mac下shell介绍</h2><p>Shell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。</p><p>Linux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。</p><pre><code class="sh">cat /etc/shells</code></pre><p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，目前常用的 Linux 系统和  OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh，这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看  zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」</p><h3 id="安装使用on-my-zsh">  <a href="#安装使用on-my-zsh" class="headerlink" title="安装使用on-my-zsh"></a>安装使用on-my-zsh</h3><ol>  <li>    <p>通过git 把oh-my-zsh 下载下来</p>    <pre><code class="sh">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre>  </li>  <li>    <p>添加配置文件并设置为默认的shell</p>    <pre><code class="sh">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcchsh -s /bin/zsh</code></pre>    <p>      <strong>注:</strong> .zshrc 就相当于.bashrc了以后配置环境就在.zshrc中配置就行</p>  </li>  <li>    <p>配置oh-my-zsh 的主题</p>    <p>oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考      <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">主题预览</a>，选好主题了，接下来就是配置了。编辑~/.zshrc 文件</p>    <pre><code class="sh">vim ~/.zshrc#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的ZSH_THEME=&quot;af-magic&quot;</code></pre>  </li>  <li>    <p>oh-my-zsh 就配置完了。这里只是简单的介绍oh-my-zsh。oh-my-zsh 功能还是很丰富的，更多oh-my-zsh请移步      <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh GitHub地址</a>    </p>  </li></ol><h2 id="安装tmux">  <a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><p>Tmux 是一个工具，用于在一个终端窗口中运行多个终端会话。不仅如此，你还可以通过 Tmux 使终端会话运行于后台或是按需接入、断开会话，这个功能非常实用。</p><ol>  <li>    <p>先安装Homebrew，这个是Mac平台的包管理器。用来安装一些开发工具还是很方便。Mac系统自带了ruby的环境，我们通过ruby来安装Homebrew</p>    <pre><code class="sh">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre>  </li>  <li>    <p>通过homebrew 安装tmux</p>    <pre><code class="sh">brew install tmux</code></pre>  </li>  <li>    <p>就是这么简单tmux就装完了</p>  </li></ol><p>下一篇会讲具体的使用方法，包括iterm快捷键，tmux的使用</p>]]></content>
    
    
    
    <tags>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell 脚本中读取参数值</title>
    <link href="/2017/05/25/shell%20%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E5%80%BC/"/>
    <url>/2017/05/25/shell%20%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>shell 脚本中读取参数值</p><p>通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了</p><h2 id="根据参数位置直接获取">  <a href="#根据参数位置直接获取" class="headerlink" title="根据参数位置直接获取"></a>根据参数位置直接获取</h2><ol>  <li>    <p>先定义一个脚本test.sh，打印位置参数</p>    <pre><code class="ssh">#!/bin/bashecho $1echo $2</code></pre>  </li>  <li>    <p>执行test.sh脚本</p>    <pre><code class="ssh">./test.sh haha hehehe</code></pre>    <p>执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。</p>    <a id="more"></a>  </li></ol><h2 id="指定key-获取参数">  <a href="#指定key-获取参数" class="headerlink" title="指定key 获取参数"></a>指定key 获取参数</h2><ol>  <li>    <p>一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义</p>    <pre><code class="ssh">#!/bin/bash#先定义接收各个参数值的变量IP_VALUE=&quot;&quot;; NODE_VALUE=&quot;&quot;;VIP_VALUE=&quot;&quot;;while true;do     if [ ! $2 ]; then break; fi    case $1 in        -i|--ip)            case $2 in            &quot;&quot;)IP_VALUE=&quot;&quot;;shift 2;;            *)IP_VALUE=$2;shift 2;;            esac;;        -n|--node)            case $2 in            &quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;            *)NODE_VALUE=$2;shift 2;;            esac;;        -v|--vip)            case $2 in            &quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;            *)NODE_VALUE=$2;shift 2;;            esac;;         --) shift ;break ;;         *) break;;        esacdoneif [ -z &quot;${IP_VALUE}&quot; ];    then echo &quot;error: ip is not found.&quot;;             exit 1; fiif [ -z &quot;${NODE_VALUE}&quot; ];  then echo &quot;error: node is not found.&quot;;           exit 1; fiif [ -z &quot;${VIP_VALUE}&quot; ];   then echo &quot;error: vip is not found.&quot;;            exit 1; fi</code></pre>    <ul>      <li>通过while 循环参数的$1 和$2 取key 和 value。</li>      <li>case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:        <code>./test.sh -v kkk -n bbbb</code> 读取到如果执行了 shift 2,它就会把-v kkk 给扔了</li>      <li>底下的if 是判断有没有读取到想要的值</li>    </ul>  </li>  <li>    <p>其他的方式去根据key获取参数</p>    <ul>      <li>一个是getopts 但是getopts不支持长选项，具体可以参考        <a href="http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html" target="_blank" rel="noopener">getopts命令行参数处理</a>      </li>      <li>另一个是getopt，        <a href="http://blog.csdn.net/wh211212/article/details/53750366" target="_blank" rel="noopener">shell中使用getopts 和 getopt</a>      </li>    </ul>  </li></ol><p>个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg简易介绍</title>
    <link href="/2017/05/22/ffmpeg%E7%AE%80%E6%98%93%E4%BB%8B%E7%BB%8D/"/>
    <url>/2017/05/22/ffmpeg%E7%AE%80%E6%98%93%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="媒体文件结构">  <a href="#媒体文件结构" class="headerlink" title="媒体文件结构"></a>媒体文件结构</h2><p>一个媒体文件并不像许多人想象的那样，是将媒体内容编码起来直接作为文件的。实际上，它通常是由多个不同种类的媒体流（ Stream ）组成，再以特定的封装格式封装起来的。</p><p>比较常见的媒体流就是视频流跟音频流了，顾名思义，视频流存储的就是视频信息，音频流存储的就是音频信息。一个视频流或者音频流的内容，就是以特定的编码格式所存储的视频或音频信息。</p><p>  <strong>一个文件的里面的媒体流所采用的编码格式跟这个文件的后缀名并没有完全的必然联系。</strong>  <strong>文件的后缀名通常就代表这个文件的封装格式。</strong></p><h2 id="ffmpeg-安装">  <a href="#ffmpeg-安装" class="headerlink" title="ffmpeg 安装"></a>ffmpeg 安装</h2><p>自行下载使用系统安装对应的安装包  <a href="https://ffmpeg.org/download.html" target="_blank" rel="noopener">官网下载</a></p><p>以下使用的平台都为Mac系统下</p><a id="more"></a><h2 id="开始使用">  <a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><ol>  <li>    <p>打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用</p>    <pre><code class="ssh">ffmpeg -help</code></pre>    <pre><code class="ssh">ffmpeg version 3.3 Copyright (c) 2000-2017 the FFmpeg developers  built with Apple LLVM version 8.1.0 (clang-802.0.41)  configuration: --prefix=/usr/local/Cellar/ffmpeg/3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda  libavutil      55. 58.100 / 55. 58.100  libavcodec     57. 89.100 / 57. 89.100  libavformat    57. 71.100 / 57. 71.100  libavdevice    57.  6.100 / 57.  6.100  libavfilter     6. 82.100 /  6. 82.100  libavresample   3.  5.  0 /  3.  5.  0  libswscale      4.  6.100 /  4.  6.100  libswresample   2.  7.100 /  2.  7.100  libpostproc    54.  5.100 / 54.  5.100Hyper fast Audio and Video encoderusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...</code></pre>    <p>重点是关注 usage: ffmpeg [options][[infile options] -i infile]… {[outfile options]      outfile}… 这句是说ffmpeg 的主要用法</p>    <p>​</p>  </li>  <li>    <p>查看ffmpeg 支持的格式</p>    <p>查看封装格式，包括音频，视频等封装格式</p>    <pre><code class="ssh">ffmpeg -formats</code></pre>    <p>查看编解码器包括音频，视频等封装格式</p>    <pre><code class="ssh">ffmpeg -codecs</code></pre>  </li>  <li>    <p>进行格式转换</p>    <pre><code class="ssh">ffmpeg -i a.mp4 b.mkv</code></pre>    <p>这里是将mp4格式的视频转换成mkv格式。</p>    <p>      <strong>注：</strong> 查看默认编码格式，以下的Matroska也就是指 mkv</p>    <pre><code class="code">ffmpeg -help muxer=Matroska#以下为摘要信息，从中可以看出默认的视频编码为h264,音频编码为ac3,字幕流编码为ass，部分格式视频不支持字幕流Muxer matroska [Matroska]:    Common extensions: mkv.    Mime type: video/x-matroska.    Default video codec: h264.    Default audio codec: ac3.    Default subtitle codec: ass.</code></pre>  </li>  <li>    <p>指定编码器进行转换</p>    <pre><code class="sh">ffmpeg -i a.mp4 -c:v hevc -c:a aac b.mkv</code></pre>    <p>      <strong>注：</strong>      <code>-c:v</code> 可以用      <code>-vcodec</code>替换，当它们的值为copy时，就表示编码格式不进行转换</p>  </li>  <li>    <p>在转换时可以进行的调整</p>    <p>在      <code>ffmpeg -help</code> 时可以看到有一些和音频，视频，字幕相关的选项</p>    <pre><code class="ssh">Video options:-vframes number     set the number of video frames to output-r rate             set frame rate (Hz value, fraction or abbreviation)-s size             set frame size (WxH or abbreviation)-aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)-bits_per_raw_sample number  set the number of bits per raw sample-vn                 disable video-vcodec codec       force video codec (&#39;copy&#39; to copy stream)-timecode hh:mm:ss[:;.]ff  set initial TimeCode value.-pass n             select the pass number (1 to 3)-vf filter_graph    set video filters-ab bitrate         audio bitrate (please use -b:a)-b bitrate          video bitrate (please use -b:v)-dn                 disable dataAudio options:-aframes number     set the number of audio frames to output-aq quality         set audio quality (codec-specific)-ar rate            set audio sampling rate (in Hz)-ac channels        set number of audio channels-an                 disable audio-acodec codec       force audio codec (&#39;copy&#39; to copy stream)-vol volume         change audio volume (256=normal)-af filter_graph    set audio filtersSubtitle options:-s size             set frame size (WxH or abbreviation)-sn                 disable subtitle-scodec codec       force subtitle codec (&#39;copy&#39; to copy stream)-stag fourcc/tag    force subtitle tag/fourcc-fix_sub_duration   fix subtitles duration-canvas_size size   set canvas size (WxH or abbreviation)-spre preset        set the subtitle options to the indicated preset</code></pre>    <p>当然还有对整个文件进行调整的参数</p>    <pre><code class="ssh">Per-file main options:-f fmt              force format-c codec            codec name-codec codec        codec name-pre preset         preset name-map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile-t duration         record or transcode &quot;duration&quot; seconds of audio/video-to time_stop       record or transcode stop time-fs limit_size      set the limit file size in bytes-ss time_off        set the start time offset-sseof time_off     set the start time offset relative to EOF-seek_timestamp     enable/disable seeking by timestamp with -ss-timestamp time     set the recording timestamp (&#39;now&#39; to set the current time)-metadata string=string  add metadata-program title=string:st=number...  add program with specified streams-target type        specify target file type (&quot;vcd&quot;, &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot; or &quot;dv50&quot; with optional prefixes &quot;pal-&quot;, &quot;ntsc-&quot; or &quot;film-&quot;)-apad               audio pad-frames number      set the number of frames to output-filter filter_graph  set stream filtergraph-filter_script filename  read stream filtergraph description from a file-reinit_filter      reinit filtergraph on input parameter changes-discard            discard-disposition        disposition</code></pre>    <p>      <a href="https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh" target="_blank" rel="noopener">文章参考</a>    </p>    <p>​</p>  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下打RPM包</title>
    <link href="/2017/05/15/Linux%E4%B8%8B%E6%89%93RPM%E5%8C%85/"/>
    <url>/2017/05/15/Linux%E4%B8%8B%E6%89%93RPM%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="工具准备">  <a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ol>  <li>    <p>安装rpmtools工具</p>    <pre><code class="sh">yum install rpmdevtools</code></pre>  </li>  <li>    <p>创建文件夹</p>    <pre><code class="sh">mkdir -pv ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}</code></pre>  </li></ol><h2 id="配置文件及源码准备">  <a href="#配置文件及源码准备" class="headerlink" title="配置文件及源码准备"></a>配置文件及源码准备</h2><ol>  <li>    <p>spec脚本文件创建，在SPECS文件夹下创建一个.spec文件 如h5-megvii.spec</p>    <pre><code class="sh">Name:           h5-megviiLicense:        copyrightVersion:        1.0Release:        1%{?dist}Summary:        HTML FaceID ServerAutoReqProv:    noGroup:          MegviiURL:            http://www.megvii.comSource:         %{name}-%{version}.tar.gzBuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root%descriptionThe rpm version of html-megvii package%prep%setup -q%build%installrm -rf $RPM_BUILD_ROOTmkdir -p $RPM_BUILD_ROOTcp -a * $RPM_BUILD_ROOT%cleanrm -rf $RPM_BUILD_ROOT%files%defattr(-,root,root,-)/opt/megvii</code></pre>    <a id="more"></a>    <p>spec脚本中各个配置项说明</p>    <pre><code class="sh">Name: 软件包的名称，后面可使用%{name}的方式引用License: 软件授权方式Version: 软件的实际版本号,后面可使用%{version}引用Release: 发布序列号,标明第几次打包，后面可使用%{release}引用Summary: 软件包的内容概要AutoReqProv: 此域用于指示RPM是否自动查找软件所需的共享库与其提供的共享库Group: 软件分组URL: 软件的主页Source: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%{source1}、%{source2}引用BuildRoot: 这个是安装或编译时使用的“虚拟目录”,一般定义为:%{_tmppath}/%{name}-%{version}-%{release}-root%description 软件的详细说明%prep 预处理脚本%setup 把源码包解压并放好,将SOURCES下的tar.gz 文件解压至BUILD文件夹下%build 开始构建包%install 开始把软件安装到虚拟的根目录中%clean 清理临时文件%files 定义那些文件或目录会放入rpm中,files下的文件，必须是tar包解压开存在的文件%defattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755</code></pre>    <p>      <strong>注1:</strong> SOURCES下的tar.gz包的文件名必须和SPECS下 xxx.specs 文件中的Source 保持一致。</p>    <p>      <strong>注2:</strong> SOURCES下的tar.gz包      <strong>解压开的文件夹</strong>名称也应为SPECS下 xxx.specs 文件中的Source 对应的名称(无须tar.gz)。</p>    <p>      <strong>注3:</strong> %files标签下的文件路径必须存在，如/opt/megvii ,在tar.gz 解压开的文件路径是存在的</p>  </li>  <li>    <p>添加源码文件</p>    <pre><code class="sh">tar czvf h5-megvii-1.0.tar.gz h5-megvii-1.0cp h5-megvii-1.0.tar.gz rpmbuild/SOURCES/</code></pre>  </li></ol><h2 id="执行打包命令">  <a href="#执行打包命令" class="headerlink" title="执行打包命令"></a>执行打包命令</h2><pre><code class="sh">rpmbuild --nodeps -ba rpmbuild/SPECS/h5-megvii.spec</code></pre><p>打完包之后的rpm包文件位置在  <code>rpmbuild/RPMS</code>文件夹中</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>supervisor linux后台进程管理利器</title>
    <link href="/2017/04/28/supervisor%20%E6%98%AF%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2017/04/28/supervisor%20%E6%98%AF%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>supervisor 是基于python的进程管理工具</p><h2 id="install-online">  <a href="#install-online" class="headerlink" title="install online"></a>install online</h2><ul>  <li>ubuntu 系统安装 apt-get install supervisor</li>  <li>    <p>也可以通过pip install supervisor 但是需要手动启动</p>    <h2 id="install-offline">      <a href="#install-offline" class="headerlink" title="install offline"></a>install offline</h2>  </li>  <li>    <p>下载安装包和依赖包详见官网 [      <a href="https://pypi.python.org/pypi/supervisor" target="_blank" rel="noopener">https://pypi.python.org/pypi/supervisor</a>] 3.3.1版本</p>  </li>  <li>    <p>解压安装tar.gz 然后cd 到目录中执行 python setup.py install</p>  </li>  <li>    <p>创建配置文件</p>  </li>  <li>    <p>执行      <code>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</code>创建配置文件</p>  </li>  <li>    <p>创建supervisord 放在 init.d目录 下      <strong>注：</strong> prog_bin 为supervisors 可执行文件位置</p>    <a id="more"></a>    <pre><code class="ssh"> #!/bin/sh # # /etc/rc.d/init.d/supervisord # # Supervisor is a client/server system that # allows its users to monitor and control a # number of processes on UNIX-like operating # systems. # # chkconfig: - 64 36 # description: Supervisor Server # processname: supervisord # Source init functions . /etc/rc.d/init.d/functions prog=&quot;supervisord&quot; prefix=&quot;/usr&quot; exec_prefix=&quot;${prefix}&quot; prog_bin=&quot;${exec_prefix}/bin/supervisord&quot; PIDFILE=&quot;/var/run/$prog.pid&quot; start() {        echo -n $&quot;Starting $prog: &quot;        touch $PIDFILE        daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE        sleep 1        [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;        echo } stop() {        echo -n $&quot;Shutting down $prog: &quot;        [ -f $PIDFILE ] &amp;&amp; killproc $prog || success $&quot;$prog shutdown&quot;        echo } case &quot;$1&quot; in  start)    start  ;;  stop)    stop  ;;  status)        status $prog  ;;  restart)    stop    start  ;;  *)    echo &quot;Usage: $0 {start|stop|restart|status}&quot;  ;; esac</code></pre>  </li>  <li>    <p>修改指定要运行程序配置文件</p>    <p> 编辑supervisor.conf文件中的</p>    <pre><code> [include] files = /etc/supervisord.conf.d/*.conf</code></pre>    <p>​</p>  </li></ul><h2 id="how-to-use">  <a href="#how-to-use" class="headerlink" title="how to use"></a>how to use</h2><p>在etc/supervisor.conf.d 目录下创建每个进程对应的配置文件 如：work.conf  <br>具体配置  <br>​ directory= /opt/faceid/worker //工程文件目录  <br>​ command= /opt/faceid/worker/start.sh //启动命令  <br>​ autostart=true //是否自启  <br>​ autorestart=true //是否自动重启  <br>​ startretries= 10000 //重试次数  <br>​ startsecs=1 //启动时间  <br>​ stopasgroup=true  <br>​ killasgroup=true``  <br>​ stdout_logfile_maxbytes = 50MB  <br>​ stdout_logfile_backups = 10  <br>​ stdout_logfile = /var/log/megvii/%(program_name)s.log</p><h2 id="common-command">  <a href="#common-command" class="headerlink" title="common command"></a>common command</h2><ul>  <li>supervisorctl status 查看各个进程的状态</li>  <li>supervisorctl reload 重启supervisor 下的所有进程</li>  <li>supervisorctl stop name 停止指定进程</li>  <li>supervisorctl start name 启动指定进程</li>  <li>supervisorctl restart all 重启supervisor 下的所有进程</li></ul><h2 id="FAQ">  <a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul>  <li>    <p>Error: Another program is already listening on a port</p>    <pre><code class="ssh">find / -name supervisor.sockunlink /***/supervisor.sock</code></pre>  </li>  <li>    <p>文件找不到</p>    <p>      <code>unix:///tmp/supervisor.sock no such file</code>    </p>    <p>编辑文件/etc/supervisord.conf 中的</p>    <pre><code>file = /tmp/supervisor.sock ;改成file = /var/run/supervisor.sock</code></pre>  </li></ul><p>​ 然后执行</p><pre><code class="ssh">touch /var/run/supervisor.sockservice supervisord restart</code></pre><ul>  <li>    <p>ERROR (spawn error)</p>    <p>确认脚本文件能够正常使用</p>  </li>  <li>    <p>error while loading shared libraries: libpython2.7.so.1.0</p>    <p>找到libpython2.7.so.10点位置</p>    <pre><code class="ssh">[root@testlm01v ~]# locate libpython2.7.so.1.0/usr/local/Python-2.7.11/libpython2.7.so.1.0/usr/local/lib/libpython2.7.so.1.0</code></pre>    <p>把找到的位置复制到/etc/ld.so.conf.d/python.conf中如</p>    <pre><code>[root@testlm01v /etc/ld.so.conf.d]# cat python.conf /usr/local/lib</code></pre>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
